<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinyin Reader</title>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js" integrity="sha512-JAlHYZ7sDXF98EQK5HABwb2k1jplfFP93BqY4B6fdHSh0XiAqIjO4gyXe8tdNFdHPYrg75grUX853FHYCzw3Dg==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.26.0/dist/index.min.js" integrity="sha512-59m22Tdj5NpJr4WpRAJl+HXy96LWKmG2f3drO7abM5kW6WaI7nMHVx7cwJON1z6OdCH0HaZVMnXnRsdFeHQtDA==" crossorigin="anonymous"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js" integrity="sha512-AXreDm/maQt99+BKeuV5VUY8x0xBAZPX6OYenHRlRwG/C35PKcZ7GQXITTR8Zf3cLHeTfwVDLEMBBPf7laKtAA==" crossorigin="anonymous"></script>
    <style>
      html {
        font-size: 16px;
      }
      :root {
        --hanzi-size: 1.5rem;
        --pinyin-size: 0.875rem;
        --pinyin-color: #666;
        --hanzi-color: #000;
        --hanzi-font:
          "STKaiti",
          "Kaiti SC",
          "Kaiti TC",
          "KaiTi",
          "楷体",
          "华文楷体",
          "Apple Kaiti",
          serif;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      .hidden {
        display: none !important;
      }
      body {
        font-family: Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent body scrollbars during resize */
      }
      .container {
        flex: 1;
        display: flex;
        /* gap: 1.25rem; /* Removed gap, handled by margins now */
        padding: 1.25rem;
        overflow: hidden; /* Prevent container overflow */
      }
      .input-section,
      .output-section {
        /* flex: 1; /* Replaced by more specific flex properties */
        flex-grow: 1; /* Allow sections to grow initially */
        flex-shrink: 1; /* Allow sections to shrink initially */
        flex-basis: 0; /* Distribute space equally initially */
        padding: 1.25rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
        min-width: 150px; /* Set a minimum width */
        overflow: auto; /* Handle content overflow within sections */
      }
      .input-section {
        padding-bottom: 1.5rem; /* Add extra space at the bottom */
        margin-right: 5px; /* Simulate gap */
      }
      .output-section {
        white-space: pre-wrap;
        margin-left: 5px; /* Simulate gap */
      }
      .resizer {
        flex: 0 0 5px; /* Fixed width, doesn't grow/shrink */
        cursor: col-resize;
        background: transparent; /* Invisible */
        align-self: stretch; /* Make it full height */
        /* Prevent selection of the resizer element itself */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      body.resizing { /* Add class to body during resize */
        cursor: col-resize !important; /* Force cursor */
        user-select: none; /* Prevent text selection globally */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      #visitor-counter {
        font-size: 1em;
        text-align: center;
        color: #333;
      }
      #visitor-counter #pageviews {
        font-weight: bold;
        color: #000;
      }
      .input-section.fullscreen-hidden {
        display: none;
      }
      /* Adjust fullscreen logic to account for resizer possibly being hidden */
      .input-section.fullscreen-hidden + .resizer {
        display: none;
      }
      .output-section.fullscreen {
        position: static; /* Revert positioning changes if any */
        flex-basis: 100% !important; /* Take full width */
        flex-grow: 1;
        min-width: auto; /* Override min-width if needed */
        margin-left: 0; /* Remove margin when fullscreen */
        padding: 3.75rem;
        border: none;
        border-radius: 0;
      }
      textarea {
        width: 100%;
        height: 70%; /* Adjust as needed, considering new controls */
        min-height: 150px; /* Ensure minimum height */
        padding: 1rem;
        border: none;
        font-size: 1.2rem;
        margin-bottom: 0.6rem;
        resize: vertical;
        caret-color: #007aff;
      }
      textarea:focus {
        outline: none;
      }
      textarea::placeholder {
        color: #164587;
        font-size: 1.3rem;
        opacity: 1;
      }
      .hanzi-pinyin {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        margin: 0.125rem;
        line-height: 1.2;
      }
      .pinyin {
        font-size: var(--pinyin-size);
        color: var(--pinyin-color);
      }
      .hanzi {
        font-size: var(--hanzi-size);
        color: var(--hanzi-color);
        font-family: var(--hanzi-font) !important;
      }
      .output-section.hide-pinyin .pinyin {
        display: none;
      }
      .button-container {
        position: fixed;
        bottom: 0.05rem;
        left: 0;
        width: 100%;
        display: flex;
        flex-wrap: nowrap;
        align-items: center;
        justify-content: center;
        gap: 1.25rem;
        z-index: 1001;
        background: transparent;
        padding: 0.9375rem 1.25rem;
        box-shadow: none;
      }
      .button-container button,
      .button-container label,
      .button-container select {
        align-items: center;
        justify-content: center;
        background-color: #007aff;
        color: #fff;
        border: none;
        padding: 0.5rem;
        border-radius: 0.7rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 0;
        height: 3.1875rem;
        width: auto;
        font-size: 0.8125rem;
        transition: background-color 0.3s, box-shadow 0.3s;
      }
      .button-container button:hover,
      .button-container label:hover {
        background-color: #005bb5;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      .button-container label {
        display: flex;
        flex-direction: column;
        cursor: default;
      }
      .button-container input {
        width: 2.3rem;
        border-radius: 0.2rem;
      }
      .button-container select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      #excelDropdown,
      #voiceSelect {
        width: 10rem;
      }
      .button-container select:focus {
        outline: none;
      }
      /* ----------------------------
         Popup (Apple-like UI) styles
         ---------------------------- */
      #adminPopup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      #adminPopup .admin-popup-content {
        background: #fff;
        border-radius: 20px;
        padding: 20px;
        max-width: 90%;
        max-height: 80%;
        overflow: auto;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
      }
      #adminPopup .admin-popup-content p {
        font-size: 1.1rem;
        margin-bottom: 1.25rem;
      }
      #adminPopup .admin-popup-content button {
        background-color: #007aff;
        border: none;
        color: #fff;
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 16px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        cursor: pointer;
      }
      #adminPopup .admin-popup-content button:active {
        background-color: #005bb5;
      }
      #adminMessage {
        /* Light blue background for emphasis can be re-enabled if needed */
        /* background-color: #f0f8ff; */
        border-left: 1px solid #007aff;
        padding: 1rem;
        margin: 1rem 0;
        text-align: left;
        font-size: 1.2rem;
        line-height: 1.5;
      }
      #adminMessage p {
        margin: 0.5rem 0;
      }

      /* --- START: Added Styles for Import Controls --- */
      .import-controls {
          /* Styles are mostly inline now for simplicity, but you could centralize them here */
      }
      .import-controls label {
          font-weight: 500;
      }
      .import-controls select,
      .import-controls input[type="text"],
      .import-controls button {
          font-size: 0.9rem; /* Consistent font size */
      }
      /* --- END: Added Styles for Import Controls --- */

      @media (max-width: 1200px) {

        textarea {
          min-height: 150px; /* Ensure a minimum usable height */
          height: 40vh; /* Adjust viewport height, consider new controls */
          /* Or use a fixed pixel height like: height: 200px; */
        }

        /* Stack container sections vertically */
        .container {
          flex-direction: column;
          width: 100%;
          height: auto;
          padding: 0.8rem; /* Adjust container padding */
        }
        /* Remove resizer and margins in vertical layout */
        .resizer {
            display: none;
        }
        .input-section,
        .output-section {
            margin-right: 0;
            margin-left: 0;
            margin-bottom: 1rem; /* Add space between stacked sections */
            flex-basis: auto; /* Reset basis for vertical layout */
            min-width: 0; /* Reset min-width */
            width: 100%; /* Take full width */
        }
         .input-section {
           /* Adjust padding for the input section */
           padding: 0.8rem;
           padding-bottom: 1rem; /* Reduce bottom padding slightly */
         }
         .output-section {
             min-height: 30vh; /* Give output some minimum height */
         }
        /* Hide the first 4 labels and print button */
        .button-container label:nth-of-type(-n+4),
        .print-btn {
          display: none;
        }
        /* Adjust button, label, and select heights */
        .button-container button,
        .button-container label,
        .button-container select {
          height: 2.5rem;
        }
        /* Set widths for Excel dropdown and voice select */
        #excelDropdown { width: 4rem; }
        #voiceSelect { width: 100px; }
        /* Adjust placeholder font size */
        textarea::placeholder {
          font-size: 0.9rem;
        }
        /* Adjust padding for fullscreen output */
        .output-section.fullscreen {
          padding: 0.3rem;
          height: auto; /* Let it fill */
          flex-basis: auto !important;
        }
        /* Style the button container */
        .button-container {
          position: relative; /* Change from fixed for stacking */
          bottom: auto;
          left: auto;
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          align-items: center;
          gap: 0.5rem;
          padding: 0.5rem; /* Reduce padding */
          margin-top: 0.5rem; /* Add space above buttons */
        }
      }
      @media print {
        .button-container, .resizer, .input-section {
          display: none !important;
        }
        .output-section {
            width: 100%;
            flex-basis: auto !important;
            margin: 0;
            border: none;
        }
      }
      @keyframes borderMove {
        0% {
          border-image-source: linear-gradient(45deg, #007aff, #ff007f);
        }
        50% {
          border-image-source: linear-gradient(135deg, #00ff7f, #007aff);
        }
        100% {
          border-image-source: linear-gradient(225deg, #ff007f, #00ff7f);
        }
      }
      .textarea-shine {
        border: 3px solid;
        border-image-slice: 1;
        animation: borderMove 3s infinite linear;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="input-section">
        <textarea class="textarea-shine" placeholder="This is the editor. Input your Chinese text here. Refresh the page to view the guide."></textarea>

        <!-- START: New Google Sheet Import Section -->
        <div class="import-controls" style="margin-top: 1rem; border-top: 1px solid #eee; padding-top: 1rem;">
            <h3 style="margin-bottom: 0.5rem; font-size: 1rem; color: #333;">Import from Google Sheet</h3>

            <div style="margin-bottom: 0.75rem;">
                <label for="builtInContentSelect" style="display: block; margin-bottom: 0.25rem; font-size: 0.9rem;">Select Built-in Content:</label>
                <select id="builtInContentSelect" style="width: 100%; padding: 0.5rem; border-radius: 4px; border: 1px solid #ccc;">
                    <option value="" disabled selected>-- Loading List --</option>
                </select>
            </div>

            <div style="margin-bottom: 0.75rem;">
                 <label for="customSheetIdInput" style="display: block; margin-bottom: 0.25rem; font-size: 0.9rem;">Or Enter Custom Google Sheet ID:</label>
                 <input type="text" id="customSheetIdInput" placeholder="Enter Google Sheet ID here" style="width: calc(100% - 85px); padding: 0.5rem; border-radius: 4px; border: 1px solid #ccc; margin-right: 5px; vertical-align: middle;">
                 <button id="importCustomSheetBtn" type="button" style="padding: 0.5rem 0.8rem; border-radius: 4px; background-color: #007aff; color: white; border: none; cursor: pointer; vertical-align: middle; font-size: 0.9rem;">Import</button>
            </div>
            <p style="font-size: 0.8rem; color: #666;">Sheet format: Cell A1 = Title (ignored), Cell A2 = Text content (newlines preserved).</p>
        </div>
        <!-- END: New Google Sheet Import Section -->
        <div id="visitor-counter">
          Welcome! You’re visitor #<span id="pageviews">Loading...</span>
        </div>

      </div>
      <div class="resizer"></div> <!-- Added Resizer Element -->
      <div class="output-section"></div>
    </div>
    <div class="button-container">
      <button id="toggleInput" type="button">Hide Editor</button>
      <button id="togglePinyin" type="button">Hide Pinyin</button>
      <label>Hanzi Size
        <input type="number" id="hanziSize" min="12" max="100" value="24">
      </label>
      <label>Pinyin Size
        <input type="number" id="pinyinSize" min="10" max="100" value="14">
      </label>
      <label>Pinyin Color
        <input type="color" id="pinyinColor" value="#666666">
      </label>
      <label>Hanzi Color
        <input type="color" id="hanziColor" value="#000000">
      </label>
      <!-- Excel Upload -->
      <button id="uploadExcel" type="button">Upload</button>
      <input type="file" id="excelFileInput" accept=".xlsx" style="display:none">
      <select id="excelDropdown" class="hidden">
        <option value="" disabled selected>select</option>
      </select>
      <!-- Voice / Read-Aloud -->
      <select id="voiceSelect">
        <option value="" disabled selected>Select Voice</option>
      </select>
      <button id="readAloudBtn" type="button">Read Aloud</button>
      <button id="pauseResumeBtn" type="button" disabled>Pause</button>
      <button class="print-btn" onclick="window.print()">Print This</button>
    </div>
    <!-- Popup for admin message -->
    <div id="adminPopup" class="hidden">
      <div class="admin-popup-content">
        <div id="adminMessage">
          <p>
            <strong>Accessing the Control Menu:</strong><br>
            Move your mouse cursor near the bottom of the screen, OR, Tap near the bottom of the screen.
          </p>
          <p>
            <strong>3 Ways to Input Chinese Text:</strong><br>
            (1) Enter your text directly in the editor;<br>
            (2) Paste your text into the editor;<br>
            (3) Upload an Excel file (.xlsx) where: Column A contains titles, Column B contains text. After uploading, use the select button to choose the text.<br>
            For the correct Excel format, refer to this <a href="https://docs.google.com/spreadsheets/d/1LZJ1pCm-XcmSyleROwRdPvwGbcUi52JOePWksTDVKus/edit?usp=sharing" target="_blank">Google Sheet</a>. Create your own file or download the Google Sheet and add your text. Ensure it is a Microsoft Excel (.xlsx) file.
          </p>
          <p>
            <strong>Note:</strong><br>
            The read-aloud feature is available only on PCs due to limitations in mobile phone browsers.<br>
            For the best experience, please use the Edge browser on a Windows PC.<br>
            <a href="https://linsnotes.com/apps/">Other Chinese Learning Tools</a>
          </p>
        </div>
        <button id="adminPopupCloseBtn">Noted</button>
      </div>
    </div>

    <script>
      // Ensure the script runs after the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', () => {

        // -------------------------
        // Pinyin Processing Logic (Existing)
        // -------------------------
        const inputSection = document.querySelector('.input-section');
        const outputSection = document.querySelector('.output-section');
        const textarea = document.querySelector('textarea'); // Keep this reference for main textarea
        const toggleInput = document.querySelector('#toggleInput');
        const togglePinyin = document.querySelector('#togglePinyin');
        const hanziSize = document.querySelector('#hanziSize');
        const pinyinSize = document.querySelector('#pinyinSize');
        const pinyinColor = document.querySelector('#pinyinColor');
        const hanziColor = document.querySelector('#hanziColor');

        textarea.addEventListener('input', debounce(processText, 300));

        toggleInput.addEventListener('click', () => {
          const isHidden = inputSection.classList.toggle('fullscreen-hidden');
          outputSection.classList.toggle('fullscreen', isHidden); // Add fullscreen class only when input is hidden
          toggleInput.textContent = isHidden ? 'Show Editor' : 'Hide Editor';
          // Reset flex properties if returning from fullscreen
          if (!isHidden) {
             outputSection.style.flexBasis = ''; // Let flexbox recalculate
             outputSection.style.flexGrow = '1';
             inputSection.style.flexBasis = '';
             inputSection.style.flexGrow = '1';
          }
        });

        togglePinyin.addEventListener('click', () => {
          outputSection.classList.toggle('hide-pinyin');
          togglePinyin.textContent = outputSection.classList.contains('hide-pinyin')
            ? 'Show Pinyin'
            : 'Hide Pinyin';
        });

        hanziSize.addEventListener('input', updateFontSizes);
        pinyinSize.addEventListener('input', updateFontSizes);

        pinyinColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--pinyin-color', e.target.value);
        });
        hanziColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--hanzi-color', e.target.value);
        });

        async function processText() {
          const rawText = textarea.value;
          // Avoid processing if output is hidden or during resize potentially
          if (!outputSection || outputSection.offsetParent === null) return;

          try {
            // Preserve scroll position
            const scrollY = outputSection.scrollTop;
            const scrollX = outputSection.scrollLeft;

            const pinyinData = await getPinyinData(rawText);
            const tempDiv = document.createElement('div');
            // Process text in chunks or directly? Direct seems okay for now.
            tempDiv.textContent = rawText; // Set text content first
            processTextNodes(tempDiv, pinyinData); // Then process nodes

            outputSection.innerHTML = ''; // Clear previous content
            // Append children of tempDiv to outputSection
             while (tempDiv.firstChild) {
                 outputSection.appendChild(tempDiv.firstChild);
             }

            // Restore scroll position
            outputSection.scrollTop = scrollY;
            outputSection.scrollLeft = scrollX;

          } catch (error) {
            console.error('Error processing text:', error);
            outputSection.innerHTML = '<p style="color: red;">Error processing text.</p>'; // Show error message
          }
        }

        async function getPinyinData(text) {
          const options = {
            type: 'array',
            toneType: 'symbol',
            pattern: 'pinyin',
            multiple: true,
            removeNonZh: false,
            nonZh: 'spaced',
            v: false,
            mode: 'normal'
          };
          try {
            // Use pinyinPro directly
            const result = pinyinPro.pinyin(text, options);
            // The result is already an array of pinyin strings or original non-Zh chars/spaces
            // We need to align it with the original text characters carefully
            let textIndex = 0;
            const alignedData = [];
            result.forEach(item => {
                if(textIndex < text.length) {
                    const originalChar = text[textIndex];
                    if (item === originalChar) { // Non-Zh character or space preserved
                       alignedData.push({ hanzi: originalChar, pinyin: '' });
                    } else if (isHanzi(originalChar)) { // Should be Hanzi with pinyin
                       alignedData.push({ hanzi: originalChar, pinyin: item });
                    } else {
                       // Handle potential misalignment or unexpected characters if necessary
                       // For now, assume alignment or push as non-hanzi
                       alignedData.push({ hanzi: originalChar, pinyin: '' });
                    }
                    textIndex++;
                    // Handle newline characters separately if needed, pinyin-pro might treat them differently
                     if (originalChar === '\n') {
                       // pinyin-pro might skip \n or represent it differently, adjust index if needed
                     }
                }
            });
            // Ensure the length matches the original text? Might be tricky with newlines/spaces
            // The processTextNodes function handles character-by-character matching anyway.
            // Let's simplify and assume pinyinPro gives one result per char for now.
             return result.map((pinyin, index) => ({
                 hanzi: text[index],
                 pinyin: isHanzi(text[index]) ? pinyin : '' // Assign pinyin only if it's Hanzi
             }));

          } catch (error) {
            console.error('Error fetching Pinyin data:', error);
            return text.split('').map(char => ({ hanzi: char, pinyin: '' })); // Fallback
          }
        }

        function processTextNodes(node, pinyinData) {
             const walker = document.createTreeWalker(
                 node,
                 NodeFilter.SHOW_TEXT,
                 null,
                 false
             );
             let pinyinIndex = 0;
             let nodesToReplace = [];

             let textNode;
             while ((textNode = walker.nextNode())) {
                 const chars = textNode.nodeValue.split('');
                 const fragment = document.createDocumentFragment();

                 chars.forEach((char) => {
                     if (pinyinIndex >= pinyinData.length) {
                         // Handle cases where text is longer than pinyin data (e.g., error fallback)
                         const wrapper = document.createElement('span');
                         wrapper.className = 'hanzi-pinyin';
                         wrapper.innerHTML = `<span class="pinyin"></span><span class="hanzi">${char === '\n' ? '<br>' : char}</span>`;
                         fragment.appendChild(wrapper);
                         if(char !== '\n') pinyinIndex++; // Increment index even for non-hanzi/non-newline
                         return;
                     }

                     const data = pinyinData[pinyinIndex];

                     if (char === '\n') {
                         const br = document.createElement('br');
                         fragment.appendChild(br);
                     } else {
                          const wrapper = document.createElement('span');
                          wrapper.className = 'hanzi-pinyin';
                         // Ensure we are matching the correct character
                         if (char === data.hanzi) {
                             wrapper.innerHTML = `
                               <span class="pinyin">${data.pinyin || ''}</span>
                               <span class="hanzi">${char}</span>
                             `;
                         } else {
                             // Handle potential mismatch (e.g., due to normalization or errors)
                             // For now, just display the character without pinyin
                              console.warn(`Mismatch at index ${pinyinIndex}: Text='${char}', PinyinData='${data.hanzi}'`);
                              wrapper.innerHTML = `
                                <span class="pinyin"></span>
                                <span class="hanzi">${char}</span>
                              `;
                              // Try to find the correct index? Risky. Advance index anyway.
                         }
                         fragment.appendChild(wrapper);
                     }
                     pinyinIndex++; // Increment index for every character processed (\n or other)
                 });
                 // Store original node and its replacement fragment
                 nodesToReplace.push({ original: textNode, replacement: fragment });
             }

             // Replace nodes outside the loop to avoid modifying the live tree being walked
             nodesToReplace.forEach(item => {
                 item.original.parentNode.replaceChild(item.replacement, item.original);
             });
         }

        function isHanzi(char) {
            // More comprehensive range including extensions, or keep simple? Keep simple for now.
            return /[\u4e00-\u9fff]/.test(char);
            // return /\p{Script=Han}/u.test(char); // Requires browser support for Unicode property escapes
        }

        function updateFontSizes() {
          const baseFontSize = 16;
          const hanziRem = (hanziSize.value / baseFontSize).toFixed(3);
          const pinyinRem = (pinyinSize.value / baseFontSize).toFixed(3);
          // Ensure minimum sensible values if needed
          document.documentElement.style.setProperty('--hanzi-size', `${Math.max(0.5, hanziRem)}rem`);
          document.documentElement.style.setProperty('--pinyin-size', `${Math.max(0.5, pinyinRem)}rem`);
        }

        function debounce(fn, delay) {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn.apply(this, args), delay);
          };
        }

        updateFontSizes(); // Initial call

        // -------------------------
        // Excel Upload (Existing)
        // -------------------------
        const uploadExcelButton = document.querySelector('#uploadExcel');
        const excelFileInput = document.querySelector('#excelFileInput');
        const excelDropdown = document.querySelector('#excelDropdown');

        uploadExcelButton.addEventListener('click', () => {
          excelFileInput.click();
        });

        excelFileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                // Filter for rows with at least 2 non-null columns (A and B)
                const filteredData = jsonData.slice(1).filter(row => row && row.length >= 2 && row[0] != null && row[1] != null); // Skip header, ensure A and B exist

                excelDropdown.innerHTML = '<option value="" disabled selected>Select</option>'; // Reset dropdown

                filteredData.forEach((row, index) => {
                    const option = document.createElement('option');
                    option.textContent = String(row[0]).substring(0, 50); // Limit title length display (Column A)
                    // Store the original row index (relative to filteredData) + 1 (to skip header in original jsonData) if needed
                    // Or simpler: Use the index within filteredData
                    option.value = index;
                    option.dataset.text = String(row[1]); // Store text (Column B) in data attribute
                    excelDropdown.appendChild(option);
                });

                if (filteredData.length > 0) {
                    excelDropdown.classList.remove('hidden');
                } else {
                    excelDropdown.classList.add('hidden');
                    alert("No valid data found in the Excel file (after header). Ensure Column A has titles and Column B has text.");
                }
            } catch (error) {
                 console.error("Error reading Excel file:", error);
                 alert("Error reading Excel file. Please ensure it's a valid .xlsx file with the correct format.");
                 excelDropdown.classList.add('hidden');
            }
          };
           reader.onerror = (error) => {
               console.error("File Reader Error:", error);
               alert("Could not read the file.");
           };
          reader.readAsArrayBuffer(file);
           // Clear the file input value to allow re-uploading the same file
           event.target.value = null;
        });

        excelDropdown.addEventListener('change', () => {
          const selectedOption = excelDropdown.options[excelDropdown.selectedIndex];
          // Check if it's a valid selection and has text data
          if (!selectedOption || selectedOption.disabled || !selectedOption.dataset.text) {
            return;
          }
          textarea.value = selectedOption.dataset.text;
          processText(); // Process the newly loaded text
          textarea.focus();
          textarea.scrollTop = 0;
        });

        // -------------------------------------
        // NEW: Google Sheet Import Logic
        // -------------------------------------
        const BUILT_IN_LIST_SHEET_ID = '156lq4Vwm-WmAZ3tIeYu9p5DliqVt3kXqiplkaeyq_ZM'; // *** REPLACE with your actual list sheet ID ***
        const builtInContentSelect = document.getElementById('builtInContentSelect');
        const customSheetIdInput = document.getElementById('customSheetIdInput');
        const importCustomSheetBtn = document.getElementById('importCustomSheetBtn');
        const mainTextarea = textarea; // Use existing textarea variable defined earlier

        // Function to fetch and parse CSV data from Google Sheet to get text from A2
        async function fetchSheetText(sheetId) {
            const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`; // gid=0 targets the first sheet

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error fetching sheet! Status: ${response.status}`);
                }
                const csv = await response.text();

                // Use SheetJS to parse the CSV
                const workbook = XLSX.read(csv, { type: 'string', raw: true }); // raw: true helps preserve newlines
                const firstSheetName = workbook.SheetNames[0];
                if (!firstSheetName) {
                    throw new Error('No sheet found in the fetched data.');
                }
                // Parse sheet to JSON array of arrays (rows)
                const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[firstSheetName], { header: 1, defval: "" });

                // We need text from A2. jsonData[0] is row 1, jsonData[1] is row 2.
                // jsonData[1][0] is cell A2.
                if (jsonData.length > 1 && jsonData[1].length > 0) {
                    // Ensure it's treated as a string and return
                    return String(jsonData[1][0]);
                } else {
                    // A2 is missing or empty
                    console.warn(`Sheet ${sheetId}: Cell A2 is empty or missing.`);
                    alert(`Warning: Sheet ${sheetId} has no content in cell A2.`);
                    return ""; // Return empty string if A2 is not present
                }

            } catch (error) {
                console.error(`Error loading or parsing sheet data for ID [${sheetId}]:`, error);
                alert(`Error loading content from Google Sheet ID: ${sheetId}.\nCheck the ID and ensure the sheet is public ('Anyone with link can view').\nDetails: ${error.message}`);
                return null; // Indicate failure
            }
        }

        // Function to load the list of built-in content titles and IDs
        async function loadBuiltInList() {
             // Check if BUILT_IN_LIST_SHEET_ID is set
             if (!BUILT_IN_LIST_SHEET_ID || BUILT_IN_LIST_SHEET_ID === 'xxxxxxxx') {
                 console.warn("Built-in list Sheet ID is not set. Skipping list load.");
                 builtInContentSelect.innerHTML = '<option value="" disabled selected>-- List ID Not Configured --</option>';
                 builtInContentSelect.disabled = true;
                 return;
             }

             const listUrl = `https://docs.google.com/spreadsheets/d/${BUILT_IN_LIST_SHEET_ID}/export?format=csv&gid=0`;
             try {
                const response = await fetch(listUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error fetching list sheet! Status: ${response.status}`);
                }
                const csv = await response.text();
                const workbook = XLSX.read(csv, { type: 'string' });
                const firstSheetName = workbook.SheetNames[0];
                 if (!firstSheetName) {
                    throw new Error('No sheet found in the list workbook.');
                }
                const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[firstSheetName], { header: 1, defval: "" });

                // Clear placeholder and add default option
                builtInContentSelect.innerHTML = '<option value="" disabled selected>-- Select Content --</option>';

                // Start from row 1 (index 1) as row 0 is the header
                let count = 0;
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    // Check if row and cells A, B exist and are not empty strings
                    if (row && row.length >= 2 && String(row[0]).trim() && String(row[1]).trim()) {
                        const title = String(row[0]).trim();
                        const sheetId = String(row[1]).trim();
                        const option = document.createElement('option');
                        option.value = sheetId;
                        option.textContent = title;
                        builtInContentSelect.appendChild(option);
                        count++;
                    }
                }
                 builtInContentSelect.disabled = (count === 0); // Disable if no items loaded
                 if(count === 0) {
                      builtInContentSelect.innerHTML = '<option value="" disabled selected>-- No Content Found --</option>';
                 }

             } catch (error) {
                  console.error("Error loading built-in content list:", error);
                  builtInContentSelect.innerHTML = `<option value="" disabled selected>-- Error Loading List (${error.message.substring(0,30)}) --</option>`;
                  builtInContentSelect.disabled = true;
                  alert(`Failed to load the built-in content list from Sheet ID: ${BUILT_IN_LIST_SHEET_ID}.\nCheck the ID and ensure the sheet is public.\nDetails: ${error.message}`);
             }
        }

        // Event Listener for Built-in Content Dropdown
        builtInContentSelect.addEventListener('change', async (event) => {
            const selectedSheetId = event.target.value;
            if (!selectedSheetId || event.target.options[event.target.selectedIndex].disabled) return; // Ignore placeholder/disabled

            const originalOptionText = event.target.options[event.target.selectedIndex].text;
            event.target.options[event.target.selectedIndex].text = "Loading...";
            mainTextarea.disabled = true;
            importCustomSheetBtn.disabled = true; // Also disable custom import button

            const text = await fetchSheetText(selectedSheetId);

            mainTextarea.disabled = false;
            importCustomSheetBtn.disabled = false;
            // Restore text only if the option still exists (might change if list reloads)
            if(event.target.options[event.target.selectedIndex]) {
                 event.target.options[event.target.selectedIndex].text = originalOptionText;
            }

            if (text !== null) { // Check if fetch was successful (not null)
                mainTextarea.value = text; // Update textarea
                processText(); // Trigger pinyin processing
                customSheetIdInput.value = ''; // Clear custom input field
                mainTextarea.focus();
                mainTextarea.scrollTop = 0; // Scroll textarea to top
            } else {
                 // Error occurred, alert was shown in fetchSheetText
                 event.target.value = ""; // Reset dropdown if loading failed
            }
        });

        // Event Listener for Custom Import Button
        importCustomSheetBtn.addEventListener('click', async () => {
            const customSheetId = customSheetIdInput.value.trim();
            if (!customSheetId) {
                alert("Please enter a Google Sheet ID.");
                customSheetIdInput.focus();
                return;
            }

            importCustomSheetBtn.textContent = "Importing...";
            importCustomSheetBtn.disabled = true;
            mainTextarea.disabled = true;
            builtInContentSelect.disabled = true; // Disable dropdown during custom import

            const text = await fetchSheetText(customSheetId);

            importCustomSheetBtn.textContent = "Import";
            importCustomSheetBtn.disabled = false;
            mainTextarea.disabled = false;
            // Re-enable dropdown only if it wasn't disabled due to error/empty list initially
            if (builtInContentSelect.options.length > 1 && builtInContentSelect.options[0].value === "") { // Check if it has selectable options
                builtInContentSelect.disabled = false;
            }


            if (text !== null) { // Check if fetch was successful
                mainTextarea.value = text; // Update textarea
                processText(); // Trigger pinyin processing
                builtInContentSelect.value = ""; // Reset dropdown selection
                mainTextarea.focus();
                mainTextarea.scrollTop = 0;
            } else {
                // Error occurred, alert was shown in fetchSheetText
                customSheetIdInput.focus(); // Keep focus on input if error
            }
        });

        // --- Load the built-in list when the page loads ---
        loadBuiltInList();
        // --- END Google Sheet Import Logic ---


        // -------------------------
        // Speech Synthesis (Existing)
        // -------------------------
        const voiceSelect = document.getElementById('voiceSelect');
        const readAloudBtn = document.getElementById('readAloudBtn');
        const pauseResumeBtn = document.getElementById('pauseResumeBtn');
        let utterance = null;
        let isPaused = false;
        let originalText = '';
        let resumeOffset = 0; // tracks the index in originalText where speaking paused
        let isEdge = false; // Keep edge detection as is

        function detectDeviceAndBrowser() {
           const userAgent = navigator.userAgent.toLowerCase();
           let device = 'other';
           let browser = 'other';
           if (/windows nt/i.test(userAgent)) device = 'windows';
           else if (/macintosh/i.test(userAgent) && !/iphone|ipad/.test(userAgent)) device = 'mac';
           else if (/ipad|iphone|ipod/.test(userAgent) && !window.MSStream) device = 'ios';
           else if (/android/i.test(userAgent)) device = 'android';

           if (userAgent.indexOf('edg') > -1) browser = 'edge';
           else if (userAgent.indexOf('chrome') > -1 && userAgent.indexOf('safari') > -1 && userAgent.indexOf('opr') === -1) browser = 'chrome'; // More specific check
           else if (userAgent.indexOf('firefox') > -1) browser = 'firefox';
           else if (userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') === -1) browser = 'safari'; // Ensure it's not Chrome
           else if (userAgent.indexOf('opr') > -1 || userAgent.indexOf('opera') > -1) browser = 'opera';
           else if (userAgent.indexOf('trident') > -1) browser = 'ie';

           return { device, browser };
        }

        function populateVoiceList() {
           // Defensive check for speech synthesis support
           if (!('speechSynthesis' in window)) {
               console.warn("Speech Synthesis not supported in this browser.");
               readAloudBtn.disabled = true;
               pauseResumeBtn.disabled = true;
               voiceSelect.innerHTML = '<option value="" disabled selected>Speech not supported</option>';
               return;
           }

           const voices = speechSynthesis.getVoices();
           voiceSelect.innerHTML = ''; // Clear previous options

           const chineseVoices = voices.filter(v => v.lang.toLowerCase().startsWith('zh'));

           if (chineseVoices.length === 0) {
               const option = document.createElement('option');
               option.value = "";
               option.textContent = "No Chinese voices";
               option.disabled = true;
               option.selected = true;
               voiceSelect.appendChild(option);
               readAloudBtn.disabled = true; // Disable button if no voices
               return;
           }

           readAloudBtn.disabled = false; // Enable button if voices found

           // Add a default "Select Voice" option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select Voice";
            defaultOption.disabled = true;
            defaultOption.selected = true; // Make it selected initially
            voiceSelect.appendChild(defaultOption);


           chineseVoices.forEach(voice => {
               const option = document.createElement('option');
               option.value = voice.name;
               option.textContent = `${voice.name} (${voice.lang})`;
               // Add lang attribute for potential future use
               option.setAttribute('lang', voice.lang);
               voiceSelect.appendChild(option);
           });

           // Voice pre-selection logic (remains the same)
           const { device, browser } = detectDeviceAndBrowser();
           let targetKeyword = '';
           if (device === 'windows' && browser === 'edge') targetKeyword = 'yunyang';
           else if (device === 'windows' && browser === 'chrome') targetKeyword = 'huihui'; // Google voice often named differently
           else if (device === 'mac' || device === 'ios') targetKeyword = 'ting-ting'; // Common Mac/iOS voice, was meijia before
           else if (device === 'android') targetKeyword = 'taiwan'; // Android often uses network voices

           let found = false;
           if (targetKeyword) {
               for (let i = 0; i < voiceSelect.options.length; i++) {
                   if (voiceSelect.options[i].value.toLowerCase().includes(targetKeyword)) {
                       voiceSelect.selectedIndex = i;
                       found = true;
                       break;
                   }
               }
           }

            // If no specific voice found or needed, try to select a Mandarin mainland voice first
             if (!found) {
                 for (let i = 0; i < voiceSelect.options.length; i++) {
                     const lang = voiceSelect.options[i].getAttribute('lang');
                     if (lang && lang.toLowerCase() === 'zh-cn') {
                         voiceSelect.selectedIndex = i;
                         found = true;
                         break;
                     }
                 }
             }

           // If still not found, select the first *actual* voice option (index 1, as index 0 is "Select Voice")
           if (!found && voiceSelect.options.length > 1) {
               voiceSelect.selectedIndex = 1;
           }
        }

        // Ensure voices are loaded, might take time
        if (speechSynthesis.getVoices().length === 0 && 'speechSynthesis' in window) { // Add check for synthesis support
             speechSynthesis.onvoiceschanged = populateVoiceList;
        } else {
             populateVoiceList(); // Populate immediately if voices are already available or synthesis not supported
        }

        const { device: currentDevice, browser: currentBrowser } = detectDeviceAndBrowser();
         isEdge = (currentDevice === 'windows' && currentBrowser === 'edge');


         function readAloud() {
             const text = mainTextarea.value.trim(); // Use mainTextarea reference
             if (!text) {
                 alert('Please enter or import some text first.');
                 return;
             }
             if (!('speechSynthesis' in window) || !voiceSelect.value) {
                 alert('Speech synthesis is not available or no voice is selected.');
                 return;
             }


             // Cancel any ongoing speech
             if (speechSynthesis.speaking || speechSynthesis.pending) {
                 isPaused = false; // Reset pause state
                 speechSynthesis.cancel();
                 // Short delay before starting new speech, especially after cancel
                 setTimeout(() => startSpeech(text), 100);
                 return;
             }

             startSpeech(text);
         }

         function startSpeech(text) {
             const selectedVoiceName = voiceSelect.value;
             // This check is technically redundant now due to the check in readAloud, but harmless
             if (!selectedVoiceName) {
                 alert('Please select a Chinese voice first.');
                 return;
             }

             const voiceObj = speechSynthesis.getVoices().find(v => v.name === selectedVoiceName);
             if (!voiceObj) {
                 alert('Selected voice not found. Please try another.');
                 populateVoiceList(); // Refresh list in case it changed
                 return;
             }

             utterance = new SpeechSynthesisUtterance(text);
             utterance.voice = voiceObj;
             utterance.lang = voiceObj.lang; // Set language for better pronunciation
             utterance.rate = 0.8;
             utterance.pitch = 1.0; // Reset pitch to normal
             utterance.volume = 1.0; // Ensure volume is max

             isPaused = false;
             pauseResumeBtn.disabled = false;
             pauseResumeBtn.textContent = 'Pause';
             originalText = text; // Store the text being spoken
             resumeOffset = 0; // Reset offset

             utterance.onstart = () => {
                 // console.log('Speech started');
                 isPaused = false;
                 pauseResumeBtn.textContent = 'Pause';
                 pauseResumeBtn.disabled = false;
             };

             utterance.onpause = () => {
                  // console.log('Speech paused');
                  isPaused = true;
                  pauseResumeBtn.textContent = 'Resume';
             };

              utterance.onresume = () => {
                   // console.log('Speech resumed');
                   isPaused = false;
                   pauseResumeBtn.textContent = 'Pause';
              };

             utterance.onend = () => {
                 // console.log('Speech ended');
                 isPaused = false;
                 pauseResumeBtn.disabled = true;
                 pauseResumeBtn.textContent = 'Pause';
                 utterance = null; // Clean up utterance object
                 resumeOffset = 0;
                 originalText = '';
             };

             utterance.onerror = (event) => {
                 console.error('SpeechSynthesis Error:', event.error);
                 alert(`Speech error: ${event.error}`);
                 isPaused = false;
                 pauseResumeBtn.disabled = true;
                 pauseResumeBtn.textContent = 'Pause';
                 utterance = null;
                 resumeOffset = 0;
                 originalText = '';
             };

             // Edge boundary workaround (remains the same)
             if (isEdge) {
                 utterance.onboundary = (event) => {
                     // console.log('Boundary event:', event.name, event.charIndex);
                     if (event.name === 'word') { // Track word boundaries for resume
                         resumeOffset = event.charIndex;
                     } else if (event.name === 'sentence') {
                         // Might be useful for highlighting, but primarily using word for resume offset
                     }
                 };
             }

             speechSynthesis.speak(utterance);
         }

        readAloudBtn.addEventListener('click', readAloud);

        pauseResumeBtn.addEventListener('click', () => {
            if (!utterance && !speechSynthesis.speaking && !speechSynthesis.pending) {
                // Nothing to pause/resume
                pauseResumeBtn.disabled = true;
                return;
            }

             if (isEdge) {
                 // Edge workaround for pause/resume
                 if (!isPaused) { // Currently speaking, want to pause
                     speechSynthesis.cancel(); // Edge doesn't support pause well, so cancel
                     isPaused = true;
                     pauseResumeBtn.textContent = 'Resume';
                     // Keep button enabled to allow resume
                     console.log(`Edge: Paused (cancelled) at approx offset: ${resumeOffset}`);
                 } else { // Currently "paused" (cancelled), want to resume
                     isPaused = false;
                     pauseResumeBtn.textContent = 'Pause';
                     // Calculate remaining text carefully using the stored offset
                     const remainingText = originalText.substring(resumeOffset);

                     if (remainingText.trim().length > 0) {
                        console.log(`Edge: Resuming speech from offset: ${resumeOffset}`);
                        // Start speech with the remaining text
                        // We need to create a new utterance instance for Edge resume via cancel/speak
                        startSpeech(remainingText); // This will create new utterance, set handlers, etc.
                        // NOTE: startSpeech resets originalText. If we need the *absolute* original text later,
                        // we might need another variable. But for resuming, originalText being the *currently*
                        // spoken full segment (initially the whole text, then the remainder) works with startSpeech.
                        // Let's refine: We want 'originalText' to remain the FULL text from the initial click.
                        // And we pass the substring to startSpeech.

                        // --- Refined Edge Resume ---
                        // Store the full original text elsewhere if needed after resume
                        // For now, let's try modifying startSpeech or creating a helper:

                         function startSpeechFromOffset(fullText, offset) {
                              const textToSpeak = fullText.substring(offset);
                              if(!textToSpeak.trim()) return; // Nothing left

                              const selectedVoiceName = voiceSelect.value;
                              if (!selectedVoiceName) return; // Voice gone?
                              const voiceObj = speechSynthesis.getVoices().find(v => v.name === selectedVoiceName);
                              if (!voiceObj) return; // Voice gone?

                              const resumedUtterance = new SpeechSynthesisUtterance(textToSpeak);
                              resumedUtterance.voice = voiceObj;
                              resumedUtterance.lang = voiceObj.lang;
                              resumedUtterance.rate = 0.8;
                              resumedUtterance.pitch = 1.0;
                              resumedUtterance.volume = 1.0;

                              isPaused = false;
                              pauseResumeBtn.disabled = false;
                              pauseResumeBtn.textContent = 'Pause';
                              // DO NOT reset originalText here. Resume offset is managed via boundary.
                              // utterance assignment will happen below

                              resumedUtterance.onstart = () => { isPaused = false; pauseResumeBtn.textContent = 'Pause'; pauseResumeBtn.disabled = false; };
                              resumedUtterance.onend = () => {
                                   isPaused = false; pauseResumeBtn.disabled = true; pauseResumeBtn.textContent = 'Pause';
                                   utterance = null; resumeOffset = 0; originalText = ''; // Clear state fully on natural end
                              };
                              resumedUtterance.onerror = (event) => {
                                   console.error('SpeechSynthesis Error (Resume):', event.error);
                                   alert(`Speech error on resume: ${event.error}`);
                                   isPaused = false; pauseResumeBtn.disabled = true; pauseResumeBtn.textContent = 'Pause';
                                   utterance = null; resumeOffset = 0; originalText = '';
                              };

                              if (isEdge) {
                                   const baseOffset = offset; // Capture the starting offset for this segment
                                   resumedUtterance.onboundary = (event) => {
                                       if (event.name === 'word') {
                                           resumeOffset = baseOffset + event.charIndex; // Calculate offset relative to original full text
                                       }
                                   };
                              }
                              utterance = resumedUtterance; // Track the new utterance
                              speechSynthesis.speak(resumedUtterance);
                         }

                         // Call the refined resume function
                         startSpeechFromOffset(originalText, resumeOffset);
                         // --- End Refined Edge Resume ---

                     } else {
                         // Nothing left to speak
                         console.log("Edge: Resume called, but nothing left to speak.");
                         pauseResumeBtn.disabled = true;
                         pauseResumeBtn.textContent = 'Pause';
                         utterance = null; // Ensure cleanup
                         isPaused = false;
                         originalText = '';
                         resumeOffset = 0;
                     }
                 }
             } else {
                 // Standard pause/resume for other browsers
                 if (speechSynthesis.speaking && !speechSynthesis.paused) {
                     speechSynthesis.pause();
                     // onpause handler should update state (isPaused=true, button text)
                 } else if (speechSynthesis.paused) {
                     speechSynthesis.resume();
                     // onresume handler should update state (isPaused=false, button text)
                 }
             }
        });


        // -------------------------
        // Auto-Show/Hide of Button Container (Existing)
        // -------------------------
        const buttonContainer = document.querySelector('.button-container');
        // Check if buttonContainer exists before adding listeners
        if (buttonContainer) {
            buttonContainer.classList.add('hidden'); // Hide initially
            const SHOW_ZONE = 180; // Activation zone height from bottom

             let hideTimeout = null;

             function showButtons() {
                 clearTimeout(hideTimeout); // Cancel any pending hide
                 buttonContainer.classList.remove('hidden');
             }

             function hideButtons() {
                 // Use a short delay before hiding in case the cursor briefly leaves the zone
                  hideTimeout = setTimeout(() => {
                      // Only hide if not hovering over buttons OR if a popup is open (like adminPopup)
                      const isAdminPopupVisible = adminPopup && !adminPopup.classList.contains('hidden');
                      if (!buttonContainer.matches(':hover') && !isAdminPopupVisible) {
                          buttonContainer.classList.add('hidden');
                      }
                  }, 300); // 300ms delay
             }

             // Show on mouse move near bottom
             document.addEventListener('mousemove', (e) => {
                 if (window.innerHeight - e.clientY < SHOW_ZONE) {
                     showButtons();
                 } else {
                     hideButtons();
                 }
             });

             // Keep visible if mouse is over the button container itself
             buttonContainer.addEventListener('mouseenter', showButtons);
             buttonContainer.addEventListener('mouseleave', hideButtons);


             // Show on touch near bottom (for touch devices)
             document.addEventListener('touchstart', (e) => {
                 if (e.touches.length > 0) {
                     const touchY = e.touches[0].clientY;
                     if (window.innerHeight - touchY < SHOW_ZONE) {
                         showButtons();
                         // Set a timeout to auto-hide after a few seconds of inactivity on touch?
                         clearTimeout(hideTimeout); // Clear any existing hide timer
                         hideTimeout = setTimeout(() => {
                              hideButtons(); // Attempt to hide after delay
                         }, 5000); // Hide after 5 seconds if no further interaction
                     } else {
                         // Don't immediately hide on touch outside zone, could be scrolling
                     }
                 }
             });
             // Clear auto-hide timer if user touches the button container itself
              buttonContainer.addEventListener('touchstart', () => {
                 clearTimeout(hideTimeout);
              });
              buttonContainer.addEventListener('touchend', () => {
                  // Optionally restart hide timer on touchend if needed
                  // hideTimeout = setTimeout(hideButtons, 5000);
              });


        } else {
            console.error("Button container not found.");
        }


        // ------------------------------------------------------------------
        //  >>> Hide Read-Aloud UI on mobile <<< (Existing)
        // ------------------------------------------------------------------
        {
          const { device } = detectDeviceAndBrowser();
          // If the device is not detected as Windows or Mac, assume mobile/tablet
          if (device !== 'windows' && device !== 'mac') {
              if(readAloudBtn) readAloudBtn.style.display = 'none';
              if(voiceSelect) voiceSelect.style.display = 'none';
              if(pauseResumeBtn) pauseResumeBtn.style.display = 'none';
             // Consider showing the alert only once using localStorage or sessionStorage
              // if (!sessionStorage.getItem('readAloudAlertShown')) {
              //     alert('Note: The read-aloud feature is best experienced on PCs.');
              //     sessionStorage.setItem('readAloudAlertShown', 'true');
              // }
          }
        }

        // -------------------------
        // Visitor Counter and Admin Popup (Existing)
        // -------------------------
        // (DOMContentLoaded ensures this runs after elements are ready)
        const pv = document.getElementById('pageviews');
        if (pv !== null) {
          const uri = location.pathname.replace(/\/$/, '') || '/'; // Handle root path
          const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;
          fetch(url)
            .then((response) => {
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return response.json();
            })
            .then((data) => {
                // Ensure count exists and format it
                const count = data && data.count ? data.count.replace(/\s/g, '') : 'N/A';
                if (count !== 'N/A') {
                   pv.innerText = new Intl.NumberFormat().format(count);
                } else {
                   pv.innerText = 'N/A';
                }
            })
            .catch((error) => {
              console.error("Failed to fetch pageviews:", error);
              pv.innerText = 'N/A'; // Indicate failure to load
            });
        } else {
             console.warn("Pageviews element not found.");
        }

        const adminPopup = document.getElementById('adminPopup');
        const closeBtn = document.getElementById('adminPopupCloseBtn');

        // Show popup only if it hasn't been closed this session
        if (adminPopup && closeBtn && !sessionStorage.getItem('adminPopupClosed')) {
            adminPopup.classList.remove('hidden');
            // Hide button container when popup is shown
            if(buttonContainer) buttonContainer.classList.add('hidden');
            closeBtn.addEventListener('click', () => {
                adminPopup.classList.add('hidden');
                // Remember that the popup was closed for this session
                 sessionStorage.setItem('adminPopupClosed', 'true');
                 // Attempt to show button container again after closing popup (if needed)
                 // showButtons(); // Or let the mouse move trigger it naturally
            });
        } else if(adminPopup) {
             // Ensure it's hidden if already closed this session or elements are missing
             adminPopup.classList.add('hidden');
        }


        // -------------------------
        // Resizer Logic (Existing - Renamed from NEW)
        // -------------------------
        const resizerEl = document.querySelector('.resizer');
        const leftPanel = inputSection; // Use existing variable
        const rightPanel = outputSection; // Use existing variable

        let isPanelResizing = false;
        let panelStartX, panelStartLeftWidth, panelStartRightWidth;

        // Check if all necessary elements exist before adding listeners
        if (resizerEl && leftPanel && rightPanel) {
            resizerEl.addEventListener('mousedown', (e) => {
                 // Ignore resize if input panel is hidden (output is fullscreen)
                 if(leftPanel.classList.contains('fullscreen-hidden')) {
                     return;
                 }

                isPanelResizing = true;
                panelStartX = e.clientX;
                // Use getBoundingClientRect for width including padding/border if box-sizing is border-box
                panelStartLeftWidth = leftPanel.getBoundingClientRect().width;
                panelStartRightWidth = rightPanel.getBoundingClientRect().width;

                document.body.classList.add('resizing');

                // Attach listeners to document for global drag tracking
                document.addEventListener('mousemove', handlePanelMouseMove);
                document.addEventListener('mouseup', handlePanelMouseUp);

                // Prevent default text selection behavior during drag
                e.preventDefault();
            });

            function handlePanelMouseMove(e) {
                if (!isPanelResizing) return;

                const dx = e.clientX - panelStartX;
                let newLeftWidth = panelStartLeftWidth + dx;
                let newRightWidth = panelStartRightWidth - dx;

                // Get min-width from computed style (remove 'px')
                const leftMinWidth = parseInt(window.getComputedStyle(leftPanel).minWidth, 10) || 0;
                const rightMinWidth = parseInt(window.getComputedStyle(rightPanel).minWidth, 10) || 0;

                // Enforce minimum widths and adjust the other panel accordingly
                if (newLeftWidth < leftMinWidth) {
                    newLeftWidth = leftMinWidth;
                    // Recalculate right width based on fixed left width
                    newRightWidth = panelStartLeftWidth + panelStartRightWidth - newLeftWidth;
                }
                if (newRightWidth < rightMinWidth) {
                    newRightWidth = rightMinWidth;
                    // Recalculate left width based on fixed right width
                    newLeftWidth = panelStartLeftWidth + panelStartRightWidth - newRightWidth;
                }

                 // Final check in case both panels were adjusted and might violate min-width again
                 if (newLeftWidth < leftMinWidth) newLeftWidth = leftMinWidth;
                 if (newRightWidth < rightMinWidth) newRightWidth = rightMinWidth;

                 // Check if total width allows for min-widths (prevent infinite loop/weirdness)
                  // Avoid setting negative basis values if calculations go wrong
                  newLeftWidth = Math.max(0, newLeftWidth);
                  newRightWidth = Math.max(0, newRightWidth);


                 if (newLeftWidth + newRightWidth > panelStartLeftWidth + panelStartRightWidth + 5) { // Add buffer for rounding
                     console.warn("Resizing calculation issue detected - total width increased.");
                 }

                // Apply new widths using flex-basis in pixels. This overrides flex-grow/shrink.
                // Ensure flex-grow/shrink are 0 while resizing to prevent interference
                leftPanel.style.flexGrow = '0';
                leftPanel.style.flexShrink = '0';
                rightPanel.style.flexGrow = '0';
                rightPanel.style.flexShrink = '0';

                leftPanel.style.flexBasis = `${newLeftWidth}px`;
                rightPanel.style.flexBasis = `${newRightWidth}px`;


                // No need to preventDefault here, already done on mousedown
                // and body class handles user-select
            }

            function handlePanelMouseUp() {
                if (isPanelResizing) {
                    isPanelResizing = false;
                    document.body.classList.remove('resizing');
                    document.removeEventListener('mousemove', handlePanelMouseMove);
                    document.removeEventListener('mouseup', handlePanelMouseUp);

                    // Restore flex grow/shrink properties after resize finishes
                    // Allows panels to resize naturally with window changes if needed
                     leftPanel.style.flexGrow = '1';
                     leftPanel.style.flexShrink = '1';
                     rightPanel.style.flexGrow = '1';
                     rightPanel.style.flexShrink = '1';

                    // Optional: Could recalculate flex-basis in percentages here for responsiveness,
                    // but pixel-based basis usually works fine and maintains user preference.
                    // Or remove flex-basis entirely to let flexbox distribute based on content/initial basis=0
                    // leftPanel.style.flexBasis = '';
                    // rightPanel.style.flexBasis = '';
                }
            }
        } else {
            console.error("Resizer elements (.resizer, .input-section, .output-section) not found. Resizing disabled.");
            // Hide the resizer visually if elements are missing
            if(resizerEl) resizerEl.style.display = 'none';
        }

      }); // End of DOMContentLoaded listener
    </script>
  </body>
</html>

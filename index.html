<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinyin Reader</title>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js" integrity="sha512-JAlHYZ7sDXF98EQK5HABwb2k1jplfFP93BqY4B6fdHSh0XiAqIjO4gyXe8tdNFdHPYrg75grUX853FHYCzw3Dg==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.26.0/dist/index.min.js" integrity="sha512-59m22Tdj5NpJr4WpRAJl+HXy96LWKmG2f3drO7abM5kW6WaI7nMHVx7cwJON1z6OdCH0HaZVMnXnRsdFeHQtDA==" crossorigin="anonymous"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js" integrity="sha512-AXreDm/maQt99+BKeuV5VUY8x0xBAZPX6OYenHRlRwG/C35PKcZ7GQXITTR8Zf3cLHeTfwVDLEMBBPf7laKtAA==" crossorigin="anonymous"></script>
    <style>
      html {
        font-size: 16px;
      }
      :root {
        --hanzi-size: 1.5rem;
        --pinyin-size: 0.875rem;
        --pinyin-color: #666;
        --hanzi-color: #000;
        --hanzi-font:
          "STKaiti",
          "Kaiti SC",
          "Kaiti TC",
          "KaiTi",
          "楷体",
          "华文楷体",
          "Apple Kaiti",
          serif;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      .hidden {
        display: none !important;
      }
      body {
        font-family: Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent body scrollbars during resize */
      }
      .container {
        flex: 1;
        display: flex;
        /* gap: 1.25rem; /* Removed gap, handled by margins/resizer */
        padding: 1.25rem;
        overflow: hidden; /* Prevent container overflow */
      }
      .input-section,
      .output-section {
        /* flex: 1; /* Replaced by more specific flex properties */
        flex-grow: 1; /* Allow sections to grow initially */
        flex-shrink: 1; /* Allow sections to shrink initially */
        flex-basis: 0; /* Distribute space equally initially */
        padding: 1.25rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
        min-width: 150px; /* Set a minimum width */
        overflow: auto; /* Handle content overflow within sections */
        position: relative; /* Needed for absolute positioning within if required */
        display: flex; /* Use flex for internal layout */
        flex-direction: column; /* Stack content vertically */
      }
      .input-section {
        padding-bottom: 1.5rem; /* Add extra space at the bottom */
        /* margin-right: 5px; /* Gap handled by resizer */
      }
      .output-section {
        white-space: pre-wrap;
        /* margin-left: 5px; /* Gap handled by resizer */
      }
      .resizer {
        flex: 0 0 10px; /* Increased width for easier grabbing, still visually transparent */
        cursor: col-resize;
        background: transparent; /* Invisible */
        align-self: stretch; /* Make it full height */
        /* Prevent selection of the resizer element itself */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        position: relative;
        z-index: 1; /* Ensure resizer is clickable */
      }
      body.resizing { /* Add class to body during resize */
        cursor: col-resize !important; /* Force cursor */
        user-select: none; /* Prevent text selection globally */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      #visitor-counter {
        font-size: 1em;
        text-align: center;
        color: #333;
        margin-top: auto; /* Push counter to the bottom */
        padding-top: 0.5rem; /* Add some space above the counter */
      }
      #visitor-counter #pageviews {
        font-weight: bold;
        color: #000;
      }

      /* Fullscreen logic */
      .input-section.fullscreen-hidden {
        display: none; /* Hide input section */
      }
      .input-section.fullscreen-hidden + .resizer {
        display: none; /* Hide resizer when input is hidden */
      }
      .output-section.fullscreen {
        flex-basis: 100% !important; /* Take full width */
        flex-grow: 1 !important;
        min-width: auto !important; /* Override min-width */
        margin-left: 0 !important; /* Remove potential margin */
        border: none;
        border-radius: 0;
        padding: 1.25rem; /* Consistent padding */
      }
      /* Adjust padding for mobile fullscreen */
       @media (max-width: 1200px) {
           .output-section.fullscreen {
               padding: 0.3rem;
           }
       }

      textarea {
        width: 100%;
        /* height: 96%; /* Replaced by flex-grow */
        flex-grow: 1; /* Allow textarea to fill available space */
        padding: 1rem;
        border: none;
        font-size: 1.2rem;
        /* margin-bottom: 0.6rem; /* Handled by flex layout now */
        resize: none; /* Disable native resize, use section overflow */
        caret-color: #007aff;
        min-height: 100px; /* Ensure a minimum height */
      }
      textarea:focus {
        outline: none;
      }
      textarea::placeholder {
        color: #164587;
        font-size: 1.3rem;
        opacity: 1;
      }
      .hanzi-pinyin {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        margin: 0.125rem;
        line-height: 1.2;
      }
      .pinyin {
        font-size: var(--pinyin-size);
        color: var(--pinyin-color);
      }
      .hanzi {
        font-size: var(--hanzi-size);
        color: var(--hanzi-color);
        font-family: var(--hanzi-font) !important;
      }
      .output-section.hide-pinyin .pinyin {
        display: none;
      }
      .button-container {
        position: fixed;
        bottom: 0.05rem;
        left: 0;
        width: 100%;
        display: flex;
        flex-wrap: nowrap;
        align-items: center;
        justify-content: center;
        gap: 1.25rem;
        z-index: 1001;
        background: transparent;
        padding: 0.9375rem 1.25rem;
        box-shadow: none;
        pointer-events: none; /* Allow clicks through container initially */
      }
      .button-container > * {
         pointer-events: auto; /* Make buttons clickable */
      }

      .button-container button,
      .button-container label,
      .button-container select {
        align-items: center;
        justify-content: center;
        background-color: #007aff;
        color: #fff;
        border: none;
        padding: 0.5rem;
        border-radius: 0.7rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 0;
        height: 3.1875rem;
        width: auto;
        font-size: 0.8125rem;
        transition: background-color 0.3s, box-shadow 0.3s;
      }
      .button-container button:hover,
      .button-container label:hover {
        background-color: #005bb5;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      .button-container label {
        display: flex;
        flex-direction: column;
        cursor: default;
      }
      .button-container input {
        width: 2.3rem;
        border-radius: 0.2rem;
      }
      .button-container select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      #excelDropdown,
      #voiceSelect {
        width: 10rem;
      }
      .button-container select:focus {
        outline: none;
      }
      /* ----------------------------
         Popup (Apple-like UI) styles
         ---------------------------- */
      #adminPopup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      #adminPopup .admin-popup-content {
        background: #fff;
        border-radius: 20px;
        padding: 20px;
        max-width: 90%;
        max-height: 80%;
        overflow: auto;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
      }
      #adminPopup .admin-popup-content p {
        font-size: 1.1rem;
        margin-bottom: 1.25rem;
      }
      #adminPopup .admin-popup-content button {
        background-color: #007aff;
        border: none;
        color: #fff;
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 16px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        cursor: pointer;
      }
      #adminPopup .admin-popup-content button:active {
        background-color: #005bb5;
      }
      #adminMessage {
        border-left: 1px solid #007aff;
        padding: 1rem;
        margin: 1rem 0;
        text-align: left;
        font-size: 1.2rem;
        line-height: 1.5;
      }
      #adminMessage p {
        margin: 0.5rem 0;
      }
      @media (max-width: 1200px) {
        /* Stack container sections vertically */
        .container {
          flex-direction: column;
          width: 100%;
          height: auto; /* Allow height to adjust */
          padding: 0.8rem; /* Adjust container padding */
          overflow: visible; /* Allow content to scroll within body if needed */
        }
         body {
           overflow: auto; /* Allow body scroll on mobile */
         }
        /* Remove resizer and margins in vertical layout */
        .resizer {
            display: none;
        }
        .input-section,
        .output-section {
            margin-right: 0;
            margin-left: 0;
            margin-bottom: 1rem; /* Add space between stacked sections */
            flex-basis: auto; /* Reset basis for vertical layout */
            flex-grow: 0; /* Don't grow, rely on content height or explicit height */
             flex-shrink: 0; /* Don't shrink */
            min-width: 0; /* Reset min-width */
            width: 100%; /* Take full width */
            height: 45vh; /* Give sections explicit viewport height portions */
            min-height: 200px; /* Ensure minimum tappable area */
            overflow: auto; /* Ensure scrolling within sections */
        }
         .input-section {
           padding: 0.8rem;
         }
         /* Fullscreen logic adjustment for mobile */
         .output-section.fullscreen {
            height: auto; /* Allow fullscreen output to take needed height */
            min-height: 60vh; /* Ensure it's substantial */
            flex-grow: 1; /* Allow it to grow if needed */
         }

        /* Hide the first 4 labels and print button */
        .button-container label:nth-of-type(-n+4),
        .print-btn {
          display: none;
        }
        /* Adjust button, label, and select heights */
        .button-container button,
        .button-container label,
        .button-container select {
          height: 2.5rem;
        }
        /* Set widths for Excel dropdown and voice select */
        #excelDropdown { width: 4rem; }
        #voiceSelect { width: 100px; }
        /* Adjust placeholder font size */
        textarea::placeholder {
          font-size: 0.9rem;
        }

        /* Style the button container */
        .button-container {
          position: relative; /* Change from fixed for stacking */
          bottom: auto;
          left: auto;
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          align-items: center;
          gap: 0.5rem;
          padding: 0.5rem; /* Reduce padding */
          margin-top: 0.5rem; /* Add space above buttons */
          pointer-events: auto; /* Ensure buttons always clickable on mobile */
        }
      }
      @media print {
        body {
            height: auto;
            overflow: visible;
        }
        .container {
            display: block; /* Simple block layout for print */
            height: auto;
            padding: 0;
        }
        .button-container, .resizer, .input-section, #visitor-counter {
          display: none !important;
        }
        .output-section {
            width: 100%;
            flex-basis: auto !important;
            margin: 0;
            border: none;
            height: auto;
            overflow: visible; /* Show all content */
            padding: 0;
        }
        /* Ensure pinyin visibility for print if not explicitly hidden */
         .output-section:not(.hide-pinyin) .pinyin {
           display: block !important; /* Ensure pinyin prints unless hidden */
         }
      }
      @keyframes borderMove {
        0% {
          border-image-source: linear-gradient(45deg, #007aff, #ff007f);
        }
        50% {
          border-image-source: linear-gradient(135deg, #00ff7f, #007aff);
        }
        100% {
          border-image-source: linear-gradient(225deg, #ff007f, #00ff7f);
        }
      }
      .textarea-shine {
        border: 3px solid;
        border-image-slice: 1;
        animation: borderMove 3s infinite linear;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="input-section">
        <textarea class="textarea-shine" placeholder="This is the editor. Input your Chinese text here. Refresh the page to view the guide."></textarea>
        <div id="visitor-counter">
          Welcome! You’re visitor #<span id="pageviews">Loading...</span>
        </div>
      </div>
      <div class="resizer"></div> <!-- Added Resizer Element -->
      <div class="output-section"></div>
    </div>
    <div class="button-container">
      <button id="toggleInput" type="button">Hide Editor</button>
      <button id="togglePinyin" type="button">Hide Pinyin</button>
      <label>Hanzi Size
        <input type="number" id="hanziSize" min="12" max="100" value="24">
      </label>
      <label>Pinyin Size
        <input type="number" id="pinyinSize" min="10" max="100" value="14">
      </label>
      <label>Pinyin Color
        <input type="color" id="pinyinColor" value="#666666">
      </label>
      <label>Hanzi Color
        <input type="color" id="hanziColor" value="#000000">
      </label>
      <!-- Excel Upload -->
      <button id="uploadExcel" type="button">Upload</button>
      <input type="file" id="excelFileInput" accept=".xlsx" style="display:none">
      <select id="excelDropdown" class="hidden">
        <option value="" disabled selected>select</option>
      </select>
      <!-- Voice / Read-Aloud -->
      <select id="voiceSelect">
        <option value="" disabled selected>Select Voice</option>
      </select>
      <button id="readAloudBtn" type="button">Read Aloud</button>
      <button id="pauseResumeBtn" type="button" disabled>Pause</button>
      <button class="print-btn" onclick="window.print()">Print This</button>
    </div>
    <!-- Popup for admin message -->
    <div id="adminPopup" class="hidden">
      <div class="admin-popup-content">
        <div id="adminMessage">
          <p>
            <strong>Accessing the Control Menu:</strong><br>
            Move your mouse cursor near the bottom of the screen, OR, Tap near the bottom of the screen.
          </p>
          <p>
            <strong>3 Ways to Input Chinese Text:</strong><br>
            (1) Enter your text directly in the editor;<br>
            (2) Paste your text into the editor;<br>
            (3) Upload an Excel file (.xlsx) where: Column A contains titles, Column B contains text. After uploading, use the select button to choose the text.<br>
            For the correct Excel format, refer to this <a href="https://docs.google.com/spreadsheets/d/1LZJ1pCm-XcmSyleROwRdPvwGbcUi52JOePWksTDVKus/edit?usp=sharing" target="_blank">Google Sheet</a>. Create your own file or download the Google Sheet and add your text. Ensure it is a Microsoft Excel (.xlsx) file.
          </p>
          <p>
            <strong>Note:</strong><br>
            The read-aloud feature is available only on PCs due to limitations in mobile phone browsers.<br>
            For the best experience, please use the Edge browser on a Windows PC.<br>
            <a href="https://linsnotes.com/apps/">Other Chinese Learning Tools</a>
          </p>
        </div>
        <button id="adminPopupCloseBtn">Noted</button>
      </div>
    </div>

    <script>
      // Ensure the script runs after the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', () => {

        // -------------------------
        // Element Selectors
        // -------------------------
        const inputSection = document.querySelector('.input-section');
        const outputSection = document.querySelector('.output-section');
        const textarea = document.querySelector('textarea');
        const toggleInput = document.querySelector('#toggleInput');
        const togglePinyin = document.querySelector('#togglePinyin');
        const hanziSize = document.querySelector('#hanziSize');
        const pinyinSize = document.querySelector('#pinyinSize');
        const pinyinColor = document.querySelector('#pinyinColor');
        const hanziColor = document.querySelector('#hanziColor');
        const resizerEl = document.querySelector('.resizer');
        const buttonContainer = document.querySelector('.button-container');
        const uploadExcelButton = document.querySelector('#uploadExcel');
        const excelFileInput = document.querySelector('#excelFileInput');
        const excelDropdown = document.querySelector('#excelDropdown');
        const voiceSelect = document.getElementById('voiceSelect');
        const readAloudBtn = document.getElementById('readAloudBtn');
        const pauseResumeBtn = document.getElementById('pauseResumeBtn');
        const adminPopup = document.getElementById('adminPopup');
        const closeBtn = document.getElementById('adminPopupCloseBtn');
        const pageviewsEl = document.getElementById('pageviews');


        // Null checks for critical elements
        if (!inputSection || !outputSection || !textarea || !toggleInput || !resizerEl || !buttonContainer) {
            console.error("Critical layout elements missing. UI might not function correctly.");
            // Optionally display an error message to the user
            // document.body.innerHTML = "Error: UI components failed to load.";
            return; // Stop script execution if essential elements are missing
        }


        // -------------------------
        // Pinyin Processing Logic
        // -------------------------
        textarea.addEventListener('input', debounce(processText, 300));

        togglePinyin.addEventListener('click', () => {
          outputSection.classList.toggle('hide-pinyin');
          togglePinyin.textContent = outputSection.classList.contains('hide-pinyin')
            ? 'Show Pinyin'
            : 'Hide Pinyin';
        });

        hanziSize.addEventListener('input', updateFontSizes);
        pinyinSize.addEventListener('input', updateFontSizes);

        pinyinColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--pinyin-color', e.target.value);
        });
        hanziColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--hanzi-color', e.target.value);
        });

        async function processText() {
          const rawText = textarea.value;
          if (!outputSection || outputSection.offsetParent === null) return;

          try {
            const scrollY = outputSection.scrollTop;
            const scrollX = outputSection.scrollLeft;

            const pinyinData = await getPinyinData(rawText);
            const tempFragment = document.createDocumentFragment(); // Use fragment for efficiency
            processTextNodes(rawText, pinyinData, tempFragment); // Pass fragment

            outputSection.innerHTML = ''; // Clear previous content
            outputSection.appendChild(tempFragment); // Append new content

            outputSection.scrollTop = scrollY;
            outputSection.scrollLeft = scrollX;

          } catch (error) {
            console.error('Error processing text:', error);
            outputSection.innerHTML = '<p style="color: red;">Error processing text.</p>';
          }
        }

        async function getPinyinData(text) {
          const options = {
            type: 'array',
            toneType: 'symbol',
            pattern: 'pinyin',
            multiple: false, // Set to false, process word by word later if needed
            removeNonZh: false,
            nonZh: 'spaced', // Keep non-Zh as spaced items
            v: false,
            mode: 'normal'
          };
          try {
            // pinyinPro returns array of strings (pinyin or original non-zh)
            const result = pinyinPro.pinyin(text, options);
            // We need to carefully map this back to the original characters
            let textIdx = 0;
            const mappedResult = [];
            for (const pinyinOrChar of result) {
                if (textIdx >= text.length) break; // Safety break

                const originalChar = text[textIdx];

                if (originalChar === ' ' && pinyinOrChar === ' ') {
                    mappedResult.push({ hanzi: ' ', pinyin: '' });
                    textIdx++;
                } else if (originalChar === '\n') {
                    mappedResult.push({ hanzi: '\n', pinyin: '' });
                    textIdx++;
                    // Check if pinyinOrChar corresponds to newline or if pinyinPro skipped it
                    if (pinyinOrChar === originalChar) {
                         // Consume the item if it matches newline, otherwise assume pinyinPro skipped it
                    } else {
                        // Need to re-evaluate the current pinyinOrChar against the *next* text char
                        // This logic gets complex. Let's simplify for now.
                        continue; // Skip to next char, assuming pinyinPro handles newline internally
                    }
                } else if (isHanzi(originalChar)) {
                    mappedResult.push({ hanzi: originalChar, pinyin: pinyinOrChar });
                    textIdx++;
                } else { // Non-hanzi, non-space, non-newline
                    mappedResult.push({ hanzi: originalChar, pinyin: '' });
                    textIdx++;
                     // Consume pinyinOrChar if it matches, otherwise assume pinyinPro mapped it
                     if(pinyinOrChar !== originalChar) {
                         // Potential misalignment, log warning maybe?
                     }
                }
            }
             // Handle remaining text chars if any (e.g., trailing spaces/newlines)
             while(textIdx < text.length) {
                 mappedResult.push({ hanzi: text[textIdx], pinyin: '' });
                 textIdx++;
             }

            return mappedResult;

          } catch (error) {
            console.error('Error fetching Pinyin data:', error);
            // Fallback: return each character with empty pinyin
            return text.split('').map(char => ({ hanzi: char, pinyin: '' }));
          }
        }


        function processTextNodes(rawText, pinyinData, fragment) {
            // Simpler approach: Iterate through pinyinData which should now align with rawText
            let pinyinIndex = 0;
            for (let i = 0; i < rawText.length; i++) {
                const char = rawText[i];
                const data = pinyinData[pinyinIndex]; // Get corresponding data

                // Basic check for alignment (optional, assumes getPinyinData worked)
                if (!data || char !== data.hanzi) {
                    // console.warn(`Potential misalignment at index ${i}: Text='${char}', Data='${data ? data.hanzi : 'N/A'}'`);
                    // Fallback: render char without pinyin
                    if (char === '\n') {
                         fragment.appendChild(document.createElement('br'));
                    } else {
                        const wrapper = document.createElement('span');
                        wrapper.className = 'hanzi-pinyin';
                        wrapper.innerHTML = `<span class="pinyin"></span><span class="hanzi">${char}</span>`;
                        fragment.appendChild(wrapper);
                    }
                    // Don't increment pinyinIndex if data was missing? Or increment anyway?
                    // Let's assume alignment for now and increment.
                     if (data) pinyinIndex++;
                     continue; // Move to next character in text
                }


                if (char === '\n') {
                    fragment.appendChild(document.createElement('br'));
                } else {
                    const wrapper = document.createElement('span');
                    wrapper.className = 'hanzi-pinyin';
                    wrapper.innerHTML = `
                      <span class="pinyin">${data.pinyin || ''}</span>
                      <span class="hanzi">${char}</span>
                    `;
                    fragment.appendChild(wrapper);
                }
                pinyinIndex++; // Move to the next pinyin data item
            }
        }


        function isHanzi(char) {
            return /[\u4e00-\u9fff]/.test(char);
        }

        function updateFontSizes() {
          const baseFontSize = 16;
          const hanziRem = (hanziSize.value / baseFontSize).toFixed(3);
          const pinyinRem = (pinyinSize.value / baseFontSize).toFixed(3);
          document.documentElement.style.setProperty('--hanzi-size', `${Math.max(0.5, hanziRem)}rem`);
          document.documentElement.style.setProperty('--pinyin-size', `${Math.max(0.5, pinyinRem)}rem`);
        }

        function debounce(fn, delay) {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn.apply(this, args), delay);
          };
        }

        updateFontSizes(); // Initial call


        // -------------------------
        // Input Toggle Logic (FIXED)
        // -------------------------
        toggleInput.addEventListener('click', () => {
            const isCurrentlyHidden = inputSection.classList.contains('fullscreen-hidden');
            const isBecomingHidden = !isCurrentlyHidden;

            // Toggle classes
            inputSection.classList.toggle('fullscreen-hidden', isBecomingHidden);
            outputSection.classList.toggle('fullscreen', isBecomingHidden);

            // Toggle resizer visibility
            if (resizerEl) {
                resizerEl.style.display = isBecomingHidden ? 'none' : ''; // Use empty string to revert to default display
            }

            // Update button text
            toggleInput.textContent = isBecomingHidden ? 'Show Editor' : 'Hide Editor';

            // IMPORTANT: Reset inline flex styles on BOTH panels regardless of state change.
            // This ensures that the CSS rules (either default flex or .fullscreen) take effect
            // and overrides any styles previously set by the resizer.
            inputSection.style.removeProperty('flex-basis');
            inputSection.style.removeProperty('flex-grow');
            inputSection.style.removeProperty('flex-shrink');
            outputSection.style.removeProperty('flex-basis');
            outputSection.style.removeProperty('flex-grow');
            outputSection.style.removeProperty('flex-shrink');

            // When showing the editor (isBecomingHidden is false), the panels will
            // revert to their default flex behavior defined in CSS (likely flex: 1),
            // effectively resetting any user resize. Preserving resize state would
            // require storing/restoring flex-basis values.
        });


        // -------------------------
        // Excel Upload
        // -------------------------
        if (uploadExcelButton && excelFileInput && excelDropdown) {
            uploadExcelButton.addEventListener('click', () => {
              excelFileInput.click();
            });

            excelFileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    if(!firstSheetName) throw new Error("No sheets found in Excel file.");
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    const filteredData = jsonData.filter(row => row && row.length >= 2 && row[0] != null && row[1] != null);

                    excelDropdown.innerHTML = '<option value="" disabled selected>Select</option>'; // Reset dropdown

                    if (filteredData.length === 0) {
                         excelDropdown.classList.add('hidden');
                         alert("No valid data found (Need non-empty A and B columns). Please check the Excel file format.");
                         return; // Stop if no data
                    }

                    filteredData.forEach((row, index) => {
                        const option = document.createElement('option');
                        option.textContent = String(row[0]).substring(0, 50); // Limit title length display
                        option.value = index; // Use index as value
                        option.dataset.text = String(row[1]); // Store text in data attribute
                        excelDropdown.appendChild(option);
                    });

                    excelDropdown.classList.remove('hidden');

                } catch (error) {
                     console.error("Error reading Excel file:", error);
                     alert(`Error reading Excel file: ${error.message}. Please ensure it's a valid .xlsx file with the correct format.`);
                     excelDropdown.classList.add('hidden');
                } finally {
                     // Clear the file input value to allow re-uploading the same file
                     event.target.value = null;
                }
              };
               reader.onerror = (error) => {
                   console.error("File Reader Error:", error);
                   alert("Could not read the file.");
                   event.target.value = null; // Clear input on error too
               };
              reader.readAsArrayBuffer(file);
            });

            excelDropdown.addEventListener('change', () => {
              const selectedOption = excelDropdown.options[excelDropdown.selectedIndex];
              if (!selectedOption || selectedOption.disabled || !selectedOption.dataset.text) {
                return;
              }
              textarea.value = selectedOption.dataset.text;
              processText(); // Process the newly loaded text
            });
        } else {
             console.warn("Excel upload elements not found.");
        }

        // -------------------------
        // Speech Synthesis
        // -------------------------
        let utterance = null;
        let isPaused = false;
        let originalText = '';
        let resumeOffset = 0;
        let isEdge = false;
        let synthesisErrorAlerted = false; // Prevent multiple alerts

        function detectDeviceAndBrowser() {
           const userAgent = navigator.userAgent.toLowerCase();
           let device = 'other';
           let browser = 'other';
           if (/windows nt/i.test(userAgent)) device = 'windows';
           else if (/macintosh/i.test(userAgent) && !/iphone|ipad/.test(userAgent)) device = 'mac';
           else if (/ipad|iphone|ipod/.test(userAgent) && !window.MSStream) device = 'ios';
           else if (/android/i.test(userAgent)) device = 'android';

           if (userAgent.indexOf('edg') > -1) browser = 'edge';
           else if (userAgent.indexOf('chrome') > -1 && userAgent.indexOf('safari') > -1 && userAgent.indexOf('opr') === -1) browser = 'chrome';
           else if (userAgent.indexOf('firefox') > -1) browser = 'firefox';
           else if (userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') === -1) browser = 'safari';
           else if (userAgent.indexOf('opr') > -1 || userAgent.indexOf('opera') > -1) browser = 'opera';
           else if (userAgent.indexOf('trident') > -1) browser = 'ie';

           return { device, browser };
        }

        function populateVoiceList() {
           if (!('speechSynthesis' in window)) {
               if (!synthesisErrorAlerted) {
                    console.warn("Speech Synthesis not supported.");
                    alert("Speech Synthesis is not supported by your browser.");
                    synthesisErrorAlerted = true;
               }
               if(readAloudBtn) readAloudBtn.disabled = true;
               if(pauseResumeBtn) pauseResumeBtn.disabled = true;
               if(voiceSelect) voiceSelect.innerHTML = '<option value="" disabled selected>Not supported</option>';
               return;
           }

            try {
                const voices = speechSynthesis.getVoices();
                if (!voices || voices.length === 0) {
                     // Voices might not be loaded yet, wait for onvoiceschanged
                     if (voiceSelect && voiceSelect.options.length <= 1) { // Avoid resetting if already populated partially
                         voiceSelect.innerHTML = '<option value="" disabled selected>Loading voices...</option>';
                     }
                    return;
                }

                voiceSelect.innerHTML = ''; // Clear previous options

                const chineseVoices = voices.filter(v => v.lang && v.lang.toLowerCase().startsWith('zh'));

                if (chineseVoices.length === 0) {
                    voiceSelect.innerHTML = '<option value="" disabled selected>No Chinese voices</option>';
                    if(readAloudBtn) readAloudBtn.disabled = true;
                    return;
                }

                if(readAloudBtn) readAloudBtn.disabled = false;

                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.textContent = "Select Voice";
                defaultOption.disabled = true;
                defaultOption.selected = true;
                voiceSelect.appendChild(defaultOption);

                chineseVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute('lang', voice.lang);
                    voiceSelect.appendChild(option);
                });

                // Voice pre-selection
                const { device, browser } = detectDeviceAndBrowser();
                let targetKeyword = '';
                if (device === 'windows' && browser === 'edge') targetKeyword = 'yunyang'; // Xiaoxiao often available too
                else if (device === 'windows' && browser === 'chrome') targetKeyword = 'huihui'; // Google voice
                else if (device === 'mac' || device === 'ios') targetKeyword = 'ting-ting';
                else if (device === 'android') targetKeyword = 'taiwan'; // Often network

                let found = false;
                if (targetKeyword) {
                    for (let i = 1; i < voiceSelect.options.length; i++) { // Start from 1 to skip "Select Voice"
                        if (voiceSelect.options[i].value.toLowerCase().includes(targetKeyword)) {
                            voiceSelect.selectedIndex = i;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    for (let i = 1; i < voiceSelect.options.length; i++) {
                         const lang = voiceSelect.options[i].getAttribute('lang');
                         if (lang && lang.toLowerCase() === 'zh-cn') { // Prefer Mandarin mainland
                             voiceSelect.selectedIndex = i;
                             found = true;
                             break;
                         }
                     }
                }
                if (!found && voiceSelect.options.length > 1) {
                    voiceSelect.selectedIndex = 1; // Fallback to the first actual voice
                }
            } catch (error) {
                 console.error("Error populating voice list:", error);
                 if(voiceSelect) voiceSelect.innerHTML = '<option value="" disabled selected>Error loading voices</option>';
                 if(readAloudBtn) readAloudBtn.disabled = true;
            }
        }

        // Initial population and setup listener
         if ('speechSynthesis' in window) {
              // Check if voices are immediately available
              if (speechSynthesis.getVoices().length > 0) {
                  populateVoiceList();
              }
              // Always set up the listener for changes or delayed loading
              speechSynthesis.onvoiceschanged = populateVoiceList;
         } else {
              populateVoiceList(); // Will handle the unsupported case
         }


        const { device: currentDevice, browser: currentBrowser } = detectDeviceAndBrowser();
        isEdge = (currentDevice === 'windows' && currentBrowser === 'edge');

        function startSpeech(textToSpeak, isResume = false) {
             if (!('speechSynthesis' in window) || !textToSpeak) return;

             const selectedVoiceName = voiceSelect.value;
             if (!selectedVoiceName) {
                 if (!isResume) alert('Please select a Chinese voice first.'); // Don't alert on auto-resume
                 return;
             }

             const voiceObj = speechSynthesis.getVoices().find(v => v.name === selectedVoiceName);
             if (!voiceObj) {
                  if (!isResume) alert('Selected voice not found. Please try another.');
                  populateVoiceList(); // Refresh list
                  return;
             }

             // Cancel previous speech before starting anew, unless resuming requires it (handled in pause/resume logic)
             if (!isResume && (speechSynthesis.speaking || speechSynthesis.pending)) {
                  speechSynthesis.cancel();
                  // Short delay after cancel might be needed for some browsers
                  // setTimeout(() => startSpeech(textToSpeak, false), 100); return;
             }

             utterance = new SpeechSynthesisUtterance(textToSpeak);
             utterance.voice = voiceObj;
             utterance.lang = voiceObj.lang;
             utterance.rate = 0.8;
             utterance.pitch = 1.0;
             utterance.volume = 1.0;

             if (!isResume) {
                 originalText = textToSpeak; // Store original text only when starting fresh
                 resumeOffset = 0;
             }
             isPaused = false;

             utterance.onstart = () => {
                 isPaused = false;
                 if(pauseResumeBtn) {
                    pauseResumeBtn.textContent = 'Pause';
                    pauseResumeBtn.disabled = false;
                 }
             };

             utterance.onpause = () => { // Standard pause event
                  isPaused = true;
                  if(pauseResumeBtn) pauseResumeBtn.textContent = 'Resume';
             };

              utterance.onresume = () => { // Standard resume event
                   isPaused = false;
                   if(pauseResumeBtn) pauseResumeBtn.textContent = 'Pause';
              };

             utterance.onend = () => {
                 isPaused = false;
                 if(pauseResumeBtn) {
                    pauseResumeBtn.disabled = true;
                    pauseResumeBtn.textContent = 'Pause';
                 }
                 utterance = null; // Clean up
                 // Don't reset originalText/resumeOffset here if using Edge workaround
                 if (!isEdge) {
                     originalText = '';
                     resumeOffset = 0;
                 }
             };

             utterance.onerror = (event) => {
                 console.error('SpeechSynthesis Error:', event.error);
                 if (!synthesisErrorAlerted) {
                     alert(`Speech error: ${event.error}`);
                     synthesisErrorAlerted = true; // Show only one error alert per session potentially
                 }
                 isPaused = false;
                 if(pauseResumeBtn) {
                    pauseResumeBtn.disabled = true;
                    pauseResumeBtn.textContent = 'Pause';
                 }
                 utterance = null;
             };

             // Edge boundary workaround
             if (isEdge) {
                  const baseOffset = isResume ? resumeOffset : 0; // Adjust offset if resuming
                  utterance.onboundary = (event) => {
                      if (event.name === 'word') {
                          // Calculate the absolute position in the original text
                          resumeOffset = baseOffset + event.charIndex + event.charLength; // Track end of word
                      }
                  };
             }

             speechSynthesis.speak(utterance);
         }

        if(readAloudBtn) {
            readAloudBtn.addEventListener('click', () => {
                const text = textarea.value.trim();
                if (!text) {
                    alert('Please enter some text first.');
                    return;
                }
                // Cancel any existing speech before starting new
                 if (speechSynthesis.speaking || speechSynthesis.pending) {
                     speechSynthesis.cancel();
                     // Wait briefly for cancel to complete before starting new
                     setTimeout(() => startSpeech(text), 50);
                 } else {
                    startSpeech(text);
                 }
            });
        }

        if(pauseResumeBtn) {
            pauseResumeBtn.addEventListener('click', () => {
                if (!speechSynthesis && !utterance) {
                     pauseResumeBtn.disabled = true; // Safety check
                     return;
                }

                if (isEdge) {
                    // Edge workaround
                    if (!isPaused) { // Currently speaking (or supposed to be), want to pause
                        speechSynthesis.cancel(); // Cancel is the 'pause'
                        isPaused = true;
                        pauseResumeBtn.textContent = 'Resume';
                        // Keep button enabled
                    } else { // Currently "paused" (cancelled), want to resume
                        isPaused = false;
                        pauseResumeBtn.textContent = 'Pause';
                        const remainingText = originalText.substring(resumeOffset);
                        if (remainingText.trim().length > 0) {
                            console.log(`Resuming Edge speech from offset: ${resumeOffset}`);
                            startSpeech(remainingText, true); // Start speech with remaining text, marking as resume
                        } else {
                            // Nothing left to speak
                            pauseResumeBtn.disabled = true;
                            pauseResumeBtn.textContent = 'Pause';
                        }
                    }
                } else {
                    // Standard pause/resume
                    if (speechSynthesis.speaking && !speechSynthesis.paused) {
                        speechSynthesis.pause(); // onpause handler updates state
                    } else if (speechSynthesis.paused) {
                        speechSynthesis.resume(); // onresume handler updates state
                    } else {
                        // Not speaking or paused (e.g., finished or error), disable button
                        pauseResumeBtn.disabled = true;
                        pauseResumeBtn.textContent = 'Pause';
                    }
                }
            });
        }

        // -------------------------
        // Auto-Show/Hide of Button Container
        // -------------------------
        if (buttonContainer) {
            buttonContainer.classList.add('hidden'); // Hide initially
            const SHOW_ZONE = 180; // Activation zone height from bottom
            let hideTimeout = null;
            let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            function showButtons() {
                clearTimeout(hideTimeout);
                buttonContainer.classList.remove('hidden');
            }

            function hideButtons() {
                 hideTimeout = setTimeout(() => {
                      // Check if mouse is over the container OR if any element inside has focus
                      const hasFocusInside = buttonContainer.contains(document.activeElement);
                      if (!buttonContainer.matches(':hover') && !hasFocusInside) {
                          buttonContainer.classList.add('hidden');
                      }
                  }, 300);
            }

            if (!isTouchDevice) {
                // Desktop: Use mouse events
                document.addEventListener('mousemove', (e) => {
                    if (window.innerHeight - e.clientY < SHOW_ZONE) {
                        showButtons();
                    } else {
                        hideButtons();
                    }
                });
                buttonContainer.addEventListener('mouseenter', showButtons);
                buttonContainer.addEventListener('mouseleave', hideButtons);
                 // Keep visible if an element inside gets focus (e.g., dropdown)
                 buttonContainer.addEventListener('focusin', showButtons);
                 buttonContainer.addEventListener('focusout', hideButtons); // Hide when focus leaves container

            } else {
                // Mobile/Touch: Simpler logic - show on touch near bottom, maybe hide on scroll?
                 buttonContainer.classList.remove('hidden'); // Keep buttons visible on touch devices for now
                 buttonContainer.style.position = 'relative'; // Make it part of flow on mobile? (Handled by media query)

                 // Optional: Hide on scroll down, show on scroll up? More complex.
                 // Let's rely on the media query moving it for now.
            }
        } else {
            console.error("Button container not found.");
        }

        // ------------------------------------------------------------------
        //  Hide Read-Aloud UI on mobile
        // ------------------------------------------------------------------
        {
          const { device } = detectDeviceAndBrowser();
          if (device !== 'windows' && device !== 'mac') {
              if(readAloudBtn) readAloudBtn.style.display = 'none';
              if(voiceSelect) voiceSelect.style.display = 'none';
              if(pauseResumeBtn) pauseResumeBtn.style.display = 'none';
              // Alert removed to avoid annoyance, handled by hiding controls.
          }
        }

        // -------------------------
        // Visitor Counter and Admin Popup
        // -------------------------
        if (pageviewsEl) {
          const uri = location.pathname.replace(/\/$/, '') || '/';
          const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;
          fetch(url)
            .then((response) => {
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return response.json();
            })
            .then((data) => {
                const count = data && data.count ? data.count.replace(/\s/g, '') : 'N/A';
                if (count !== 'N/A' && !isNaN(Number(count))) { // Check if it's a number
                   pageviewsEl.innerText = new Intl.NumberFormat().format(count);
                } else {
                   pageviewsEl.innerText = '-'; // Placeholder if not number
                }
            })
            .catch((error) => {
              console.error("Failed to fetch pageviews:", error);
              pageviewsEl.innerText = '-';
            });
        } else {
             console.warn("Pageviews element not found.");
        }

        if (adminPopup && closeBtn) {
            if (!sessionStorage.getItem('adminPopupClosed')) {
                adminPopup.classList.remove('hidden');
                closeBtn.addEventListener('click', () => {
                    adminPopup.classList.add('hidden');
                    sessionStorage.setItem('adminPopupClosed', 'true');
                });
            } else {
                 adminPopup.classList.add('hidden');
            }
        }

        // -------------------------
        // Resizer Logic
        // -------------------------
        let isPanelResizing = false;
        let panelStartX, panelStartLeftWidth, panelStartRightWidth;

        if (resizerEl && leftPanel && rightPanel) { // Use existing selectors 'inputSection', 'outputSection'
            resizerEl.addEventListener('mousedown', (e) => {
                if(leftPanel.classList.contains('fullscreen-hidden')) {
                    return; // Don't allow resize when one panel is hidden
                }
                isPanelResizing = true;
                panelStartX = e.clientX;
                panelStartLeftWidth = leftPanel.getBoundingClientRect().width;
                panelStartRightWidth = rightPanel.getBoundingClientRect().width;

                document.body.classList.add('resizing'); // Style cursor, disable selection

                document.addEventListener('mousemove', handlePanelMouseMove);
                document.addEventListener('mouseup', handlePanelMouseUp);
                e.preventDefault(); // Prevent text selection start
            });

            function handlePanelMouseMove(e) {
                if (!isPanelResizing) return;

                const dx = e.clientX - panelStartX;
                let newLeftWidth = panelStartLeftWidth + dx;
                let newRightWidth = panelStartRightWidth - dx;

                const leftMinWidth = parseInt(window.getComputedStyle(leftPanel).minWidth, 10) || 50; // Ensure fallback minWidth
                const rightMinWidth = parseInt(window.getComputedStyle(rightPanel).minWidth, 10) || 50; // Ensure fallback minWidth

                // Clamp widths to min values
                 if (newLeftWidth < leftMinWidth) {
                     newLeftWidth = leftMinWidth;
                     newRightWidth = panelStartLeftWidth + panelStartRightWidth - newLeftWidth; // Adjust other panel
                 }
                 if (newRightWidth < rightMinWidth) {
                     newRightWidth = rightMinWidth;
                     newLeftWidth = panelStartLeftWidth + panelStartRightWidth - newRightWidth; // Adjust other panel
                 }
                 // Re-clamp after adjustments (in case both were below min initially)
                 if (newLeftWidth < leftMinWidth) newLeftWidth = leftMinWidth;
                 if (newRightWidth < rightMinWidth) newRightWidth = rightMinWidth;

                // Apply using flex-basis (pixels is fine here)
                leftPanel.style.flexBasis = `${newLeftWidth}px`;
                rightPanel.style.flexBasis = `${newRightWidth}px`;
                // Explicitly set grow/shrink to 0 to maintain the basis
                leftPanel.style.flexGrow = '0';
                leftPanel.style.flexShrink = '0';
                rightPanel.style.flexGrow = '0';
                rightPanel.style.flexShrink = '0';
            }

            function handlePanelMouseUp() {
                if (isPanelResizing) {
                    isPanelResizing = false;
                    document.body.classList.remove('resizing');
                    document.removeEventListener('mousemove', handlePanelMouseMove);
                    document.removeEventListener('mouseup', handlePanelMouseUp);
                    // Inline styles (flex-basis, grow/shrink 0) remain, preserving user's choice until toggleInput resets them.
                }
            }
        } else {
            console.error("Resizer elements not found or invalid. Resizing disabled.");
            if(resizerEl) resizerEl.style.display = 'none'; // Hide useless resizer
        }

      }); // End of DOMContentLoaded listener
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinyin Reader</title>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js" integrity="sha512-JAlHYZ7sDXF98EQK5HABwb2k1jplfFP93BqY4B6fdHSh0XiAqIjO4gyXe8tdNFdHPYrg75grUX853FHYCzw3Dg==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.26.0/dist/index.min.js" integrity="sha512-59m22Tdj5NpJr4WpRAJl+HXy96LWKmG2f3drO7abM5kW6WaI7nMHVx7cwJON1z6OdCH0HaZVMnXnRsdFeHQtDA==" crossorigin="anonymous"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js" integrity="sha512-AXreDm/maQt99+BKeuV5VUY8x0xBAZPX6OYenHRlRwG/C35PKcZ7GQXITTR8Zf3cLHeTfwVDLEMBBPf7laKtAA==" crossorigin="anonymous"></script>
    <style>
      html {
        font-size: 16px;
      }
      :root {
        --hanzi-size: 1.5rem;
        --pinyin-size: 0.875rem;
        --pinyin-color: #666;
        --hanzi-color: #000;
        --hanzi-font:
          "STKaiti",
          "Kaiti SC",
          "Kaiti TC",
          "KaiTi",
          "楷体",
          "华文楷体",
          "Apple Kaiti",
          serif;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      .hidden {
        display: none !important;
      }
      body {
        font-family: Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent body scrollbars during resize */
      }
      .container {
        flex: 1;
        display: flex;
        /* gap: 1.25rem; /* Removed gap, handled by margins now */
        padding: 1.25rem;
        overflow: hidden; /* Prevent container overflow */
      }
      .input-section,
      .output-section {
        /* flex: 1; /* Replaced by more specific flex properties */
        flex-grow: 1; /* Allow sections to grow initially */
        flex-shrink: 1; /* Allow sections to shrink initially */
        flex-basis: 0; /* Distribute space equally initially */
        padding: 1.25rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
        min-width: 150px; /* Set a minimum width */
        overflow: auto; /* Handle content overflow within sections */
      }
      .input-section {
        padding-bottom: 1.5rem; /* Add extra space at the bottom */
        margin-right: 5px; /* Simulate gap */
      }
      .output-section {
        white-space: pre-wrap;
        margin-left: 5px; /* Simulate gap */
      }
      .resizer {
        flex: 0 0 5px; /* Fixed width, doesn't grow/shrink */
        cursor: col-resize;
        background: transparent; /* Invisible */
        align-self: stretch; /* Make it full height */
        /* Prevent selection of the resizer element itself */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      body.resizing { /* Add class to body during resize */
        cursor: col-resize !important; /* Force cursor */
        user-select: none; /* Prevent text selection globally */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      #visitor-counter {
        font-size: 1em;
        text-align: center;
        color: #333;
      }
      #visitor-counter #pageviews {
        font-weight: bold;
        color: #000;
      }
      .input-section.fullscreen-hidden {
        display: none;
      }
      /* Adjust fullscreen logic to account for resizer possibly being hidden */
      .input-section.fullscreen-hidden + .resizer {
        display: none;
      }
      .output-section.fullscreen {
        position: static; /* Revert positioning changes if any */
        flex-basis: 100% !important; /* Take full width */
        flex-grow: 1;
        min-width: auto; /* Override min-width if needed */
        margin-left: 0; /* Remove margin when fullscreen */
        padding: 3.75rem;
        border: none;
        border-radius: 0;
      }
      textarea {
        width: 100%;
        height: 70%;
        padding: 1rem;
        border: none;
        font-size: 1.2rem;
        margin-bottom: 0.6rem;
        resize: vertical;
        caret-color: #007aff;
      }
      textarea:focus {
        outline: none;
      }
      textarea::placeholder {
        color: #164587;
        font-size: 1.3rem;
        opacity: 1;
      }
      .hanzi-pinyin {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        margin: 0.125rem;
        line-height: 1.2;
      }
      .pinyin {
        font-size: var(--pinyin-size);
        color: var(--pinyin-color);
      }
      .hanzi {
        font-size: var(--hanzi-size);
        color: var(--hanzi-color);
        font-family: var(--hanzi-font) !important;
      }
      .output-section.hide-pinyin .pinyin {
        display: none;
      }
      .button-container {
        position: fixed;
        bottom: 0.05rem;
        left: 0;
        width: 100%;
        display: flex;
        flex-wrap: nowrap;
        align-items: center;
        justify-content: center;
        gap: 1.25rem;
        z-index: 1001;
        background: transparent;
        padding: 0.9375rem 1.25rem;
        box-shadow: none;
      }
      .button-container button,
      .button-container label,
      .button-container select {
        align-items: center;
        justify-content: center;
        background-color: #007aff;
        color: #fff;
        border: none;
        padding: 0.5rem;
        border-radius: 0.7rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 0;
        height: 3.1875rem;
        width: auto;
        font-size: 0.8125rem;
        transition: background-color 0.3s, box-shadow 0.3s;
      }
      .button-container button:hover,
      .button-container label:hover {
        background-color: #005bb5;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      .button-container label {
        display: flex;
        flex-direction: column;
        cursor: default;
      }
      .button-container input {
        width: 2.3rem;
        border-radius: 0.2rem;
      }
      .button-container select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      #excelDropdown,
      #voiceSelect {
        width: 10rem;
      }
      .button-container select:focus {
        outline: none;
      }
      /* ----------------------------
         Popup (Apple-like UI) styles
         ---------------------------- */
      #adminPopup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      #adminPopup .admin-popup-content {
        background: #fff;
        border-radius: 20px;
        padding: 20px;
        max-width: 90%;
        max-height: 80%;
        overflow: auto;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
      }
      #adminPopup .admin-popup-content p {
        font-size: 1.1rem;
        margin-bottom: 1.25rem;
      }
      #adminPopup .admin-popup-content button {
        background-color: #007aff;
        border: none;
        color: #fff;
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 16px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        cursor: pointer;
      }
      #adminPopup .admin-popup-content button:active {
        background-color: #005bb5;
      }
      #adminMessage {
        /* Light blue background for emphasis can be re-enabled if needed */
        /* background-color: #f0f8ff; */
        border-left: 1px solid #007aff;
        padding: 1rem;
        margin: 1rem 0;
        text-align: left;
        font-size: 1.2rem;
        line-height: 1.5;
      }
      #adminMessage p {
        margin: 0.5rem 0;
      }
      @media (max-width: 1200px) {

        textarea {
          min-height: 150px; /* Ensure a minimum usable height */
          height: 25vh; /* Start with a viewport-relative height, but allow resize */
          /* Or use a fixed pixel height like: height: 200px; */
        }

        /* Stack container sections vertically */
        .container {
          flex-direction: column;
          width: 100%;
          height: auto;
          padding: 0.8rem; /* Adjust container padding */
        }
        /* Remove resizer and margins in vertical layout */
        .resizer {
            display: none;
        }
        .input-section,
        .output-section {
            margin-right: 0;
            margin-left: 0;
            margin-bottom: 1rem; /* Add space between stacked sections */
            flex-basis: auto; /* Reset basis for vertical layout */
            min-width: 0; /* Reset min-width */
            width: 100%; /* Take full width */
        }
         .input-section {
           /* Adjust padding for the input section */
           padding: 0.8rem;
           padding-bottom: 2rem;
         }
         .output-section {
         }
        /* Hide the first 4 labels and print button */
        .button-container label:nth-of-type(-n+4),
        .print-btn {
          display: none;
        }
        /* Adjust button, label, and select heights */
        .button-container button,
        .button-container label,
        .button-container select {
          height: 2.5rem;
        }
        /* Set widths for Excel dropdown and voice select */
        #excelDropdown { width: 4rem; }
        #voiceSelect { width: 100px; }
        /* Adjust placeholder font size */
        textarea::placeholder {
          font-size: 0.9rem;
        }
        /* Adjust padding for fullscreen output */
        .output-section.fullscreen {
          padding: 0.3rem;
          height: auto; /* Let it fill */
          flex-basis: auto !important;
        }
        /* Style the button container */
        .button-container {
          position: relative; /* Change from fixed for stacking */
          bottom: auto;
          left: auto;
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          align-items: center;
          gap: 0.5rem;
          padding: 0.5rem; /* Reduce padding */
          margin-top: 0.5rem; /* Add space above buttons */
        }
      }
      @media print {
        .button-container, .resizer, .input-section {
          display: none !important;
        }
        .output-section {
            width: 100%;
            flex-basis: auto !important;
            margin: 0;
            border: none;
        }
      }
      @keyframes borderMove {
        0% {
          border-image-source: linear-gradient(45deg, #007aff, #ff007f);
        }
        50% {
          border-image-source: linear-gradient(135deg, #00ff7f, #007aff);
        }
        100% {
          border-image-source: linear-gradient(225deg, #ff007f, #00ff7f);
        }
      }
      .textarea-shine {
        border: 3px solid;
        border-image-slice: 1;
        animation: borderMove 3s infinite linear;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="input-section">
        <textarea class="textarea-shine" placeholder="This is the editor. Input your Chinese text here. Refresh the page to view the guide."></textarea>
        <div id="visitor-counter">
          Welcome! You’re visitor #<span id="pageviews">Loading...</span>
        </div>
      </div>
      <div class="resizer"></div> <!-- Added Resizer Element -->
      <div class="output-section"></div>
    </div>
    <div class="button-container">
      <button id="toggleInput" type="button">Hide Editor</button>
      <button id="togglePinyin" type="button">Hide Pinyin</button>
      <label>Hanzi Size
        <input type="number" id="hanziSize" min="12" max="100" value="24">
      </label>
      <label>Pinyin Size
        <input type="number" id="pinyinSize" min="10" max="100" value="14">
      </label>
      <label>Pinyin Color
        <input type="color" id="pinyinColor" value="#666666">
      </label>
      <label>Hanzi Color
        <input type="color" id="hanziColor" value="#000000">
      </label>
      <!-- Excel Upload -->
      <button id="uploadExcel" type="button">Upload</button>
      <input type="file" id="excelFileInput" accept=".xlsx" style="display:none">
      <select id="excelDropdown" class="hidden">
        <option value="" disabled selected>select</option>
      </select>
      <!-- Voice / Read-Aloud -->
      <select id="voiceSelect">
        <option value="" disabled selected>Select Voice</option>
      </select>
      <button id="readAloudBtn" type="button">Read Aloud</button>
      <button id="pauseResumeBtn" type="button" disabled>Pause</button>
      <button class="print-btn" onclick="window.print()">Print This</button>
    </div>
    <!-- Popup for admin message -->
    <div id="adminPopup" class="hidden">
      <div class="admin-popup-content">
        <div id="adminMessage">
          <p>
            <strong>Accessing the Control Menu:</strong><br>
            Move your mouse cursor near the bottom of the screen, OR, Tap near the bottom of the screen.
          </p>
          <p>
            <strong>3 Ways to Input Chinese Text:</strong><br>
            (1) Enter your text directly in the editor;<br>
            (2) Paste your text into the editor;<br>
            (3) Upload an Excel file (.xlsx) where: Column A contains titles, Column B contains text. After uploading, use the select button to choose the text.<br>
            For the correct Excel format, refer to this <a href="https://docs.google.com/spreadsheets/d/1LZJ1pCm-XcmSyleROwRdPvwGbcUi52JOePWksTDVKus/edit?usp=sharing" target="_blank">Google Sheet</a>. Create your own file or download the Google Sheet and add your text. Ensure it is a Microsoft Excel (.xlsx) file.
          </p>
          <p>
            <strong>Note:</strong><br>
            The read-aloud feature is available only on PCs due to limitations in mobile phone browsers.<br>
            For the best experience, please use the Edge browser on a Windows PC.<br>
            <a href="https://linsnotes.com/apps/">Other Chinese Learning Tools</a>
          </p>
        </div>
        <button id="adminPopupCloseBtn">Noted</button>
      </div>
    </div>

    <script>
      // Ensure the script runs after the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', () => {

        // -------------------------
        // Pinyin Processing Logic (Existing)
        // -------------------------
        const inputSection = document.querySelector('.input-section');
        const outputSection = document.querySelector('.output-section');
        const textarea = document.querySelector('textarea');
        const toggleInput = document.querySelector('#toggleInput');
        const togglePinyin = document.querySelector('#togglePinyin');
        const hanziSize = document.querySelector('#hanziSize');
        const pinyinSize = document.querySelector('#pinyinSize');
        const pinyinColor = document.querySelector('#pinyinColor');
        const hanziColor = document.querySelector('#hanziColor');

        textarea.addEventListener('input', debounce(processText, 300));

        toggleInput.addEventListener('click', () => {
          const isHidden = inputSection.classList.toggle('fullscreen-hidden');
          outputSection.classList.toggle('fullscreen', isHidden); // Add fullscreen class only when input is hidden
          toggleInput.textContent = isHidden ? 'Show Editor' : 'Hide Editor';
          // Reset flex properties if returning from fullscreen
          if (!isHidden) {
             outputSection.style.flexBasis = ''; // Let flexbox recalculate
             outputSection.style.flexGrow = '1';
             inputSection.style.flexBasis = '';
             inputSection.style.flexGrow = '1';
          }
        });

        togglePinyin.addEventListener('click', () => {
          outputSection.classList.toggle('hide-pinyin');
          togglePinyin.textContent = outputSection.classList.contains('hide-pinyin')
            ? 'Show Pinyin'
            : 'Hide Pinyin';
        });

        hanziSize.addEventListener('input', updateFontSizes);
        pinyinSize.addEventListener('input', updateFontSizes);

        pinyinColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--pinyin-color', e.target.value);
        });
        hanziColor.addEventListener('input', (e) => {
          document.documentElement.style.setProperty('--hanzi-color', e.target.value);
        });

        async function processText() {
          const rawText = textarea.value;
          // Avoid processing if output is hidden or during resize potentially
          if (!outputSection || outputSection.offsetParent === null) return;

          try {
            // Preserve scroll position
            const scrollY = outputSection.scrollTop;
            const scrollX = outputSection.scrollLeft;

            const pinyinData = await getPinyinData(rawText);
            const tempDiv = document.createElement('div');
            // Process text in chunks or directly? Direct seems okay for now.
            tempDiv.textContent = rawText; // Set text content first
            processTextNodes(tempDiv, pinyinData); // Then process nodes

            outputSection.innerHTML = ''; // Clear previous content
            // Append children of tempDiv to outputSection
             while (tempDiv.firstChild) {
                 outputSection.appendChild(tempDiv.firstChild);
             }

            // Restore scroll position
            outputSection.scrollTop = scrollY;
            outputSection.scrollLeft = scrollX;

          } catch (error) {
            console.error('Error processing text:', error);
            outputSection.innerHTML = '<p style="color: red;">Error processing text.</p>'; // Show error message
          }
        }

        async function getPinyinData(text) {
          const options = {
            type: 'array',
            toneType: 'symbol',
            pattern: 'pinyin',
            multiple: true,
            removeNonZh: false,
            nonZh: 'spaced',
            v: false,
            mode: 'normal'
          };
          try {
            // Use pinyinPro directly
            const result = pinyinPro.pinyin(text, options);
            // The result is already an array of pinyin strings or original non-Zh chars/spaces
            // We need to align it with the original text characters carefully
            let textIndex = 0;
            const alignedData = [];
            result.forEach(item => {
                if(textIndex < text.length) {
                    const originalChar = text[textIndex];
                    if (item === originalChar) { // Non-Zh character or space preserved
                       alignedData.push({ hanzi: originalChar, pinyin: '' });
                    } else if (isHanzi(originalChar)) { // Should be Hanzi with pinyin
                       alignedData.push({ hanzi: originalChar, pinyin: item });
                    } else {
                       // Handle potential misalignment or unexpected characters if necessary
                       // For now, assume alignment or push as non-hanzi
                       alignedData.push({ hanzi: originalChar, pinyin: '' });
                    }
                    textIndex++;
                    // Handle newline characters separately if needed, pinyin-pro might treat them differently
                     if (originalChar === '\n') {
                       // pinyin-pro might skip \n or represent it differently, adjust index if needed
                     }
                }
            });
            // Ensure the length matches the original text? Might be tricky with newlines/spaces
            // The processTextNodes function handles character-by-character matching anyway.
            // Let's simplify and assume pinyinPro gives one result per char for now.
             return result.map((pinyin, index) => ({
                 hanzi: text[index],
                 pinyin: isHanzi(text[index]) ? pinyin : '' // Assign pinyin only if it's Hanzi
             }));

          } catch (error) {
            console.error('Error fetching Pinyin data:', error);
            return text.split('').map(char => ({ hanzi: char, pinyin: '' })); // Fallback
          }
        }

        function processTextNodes(node, pinyinData) {
             const walker = document.createTreeWalker(
                 node,
                 NodeFilter.SHOW_TEXT,
                 null,
                 false
             );
             let pinyinIndex = 0;
             let nodesToReplace = [];

             let textNode;
             while ((textNode = walker.nextNode())) {
                 const chars = textNode.nodeValue.split('');
                 const fragment = document.createDocumentFragment();

                 chars.forEach((char) => {
                     if (pinyinIndex >= pinyinData.length) {
                         // Handle cases where text is longer than pinyin data (e.g., error fallback)
                         const wrapper = document.createElement('span');
                         wrapper.className = 'hanzi-pinyin';
                         wrapper.innerHTML = `<span class="pinyin"></span><span class="hanzi">${char === '\n' ? '<br>' : char}</span>`;
                         fragment.appendChild(wrapper);
                         if(char !== '\n') pinyinIndex++; // Increment index even for non-hanzi/non-newline
                         return;
                     }

                     const data = pinyinData[pinyinIndex];

                     if (char === '\n') {
                         const br = document.createElement('br');
                         fragment.appendChild(br);
                     } else {
                          const wrapper = document.createElement('span');
                          wrapper.className = 'hanzi-pinyin';
                         // Ensure we are matching the correct character
                         if (char === data.hanzi) {
                             wrapper.innerHTML = `
                               <span class="pinyin">${data.pinyin || ''}</span>
                               <span class="hanzi">${char}</span>
                             `;
                         } else {
                             // Handle potential mismatch (e.g., due to normalization or errors)
                             // For now, just display the character without pinyin
                              console.warn(`Mismatch at index ${pinyinIndex}: Text='${char}', PinyinData='${data.hanzi}'`);
                              wrapper.innerHTML = `
                                <span class="pinyin"></span>
                                <span class="hanzi">${char}</span>
                              `;
                              // Try to find the correct index? Risky. Advance index anyway.
                         }
                         fragment.appendChild(wrapper);
                     }
                     pinyinIndex++; // Increment index for every character processed (\n or other)
                 });
                 // Store original node and its replacement fragment
                 nodesToReplace.push({ original: textNode, replacement: fragment });
             }

             // Replace nodes outside the loop to avoid modifying the live tree being walked
             nodesToReplace.forEach(item => {
                 item.original.parentNode.replaceChild(item.replacement, item.original);
             });
         }

        function isHanzi(char) {
            // More comprehensive range including extensions, or keep simple? Keep simple for now.
            return /[\u4e00-\u9fff]/.test(char);
            // return /\p{Script=Han}/u.test(char); // Requires browser support for Unicode property escapes
        }

        function updateFontSizes() {
          const baseFontSize = 16;
          const hanziRem = (hanziSize.value / baseFontSize).toFixed(3);
          const pinyinRem = (pinyinSize.value / baseFontSize).toFixed(3);
          // Ensure minimum sensible values if needed
          document.documentElement.style.setProperty('--hanzi-size', `${Math.max(0.5, hanziRem)}rem`);
          document.documentElement.style.setProperty('--pinyin-size', `${Math.max(0.5, pinyinRem)}rem`);
        }

        function debounce(fn, delay) {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn.apply(this, args), delay);
          };
        }

        updateFontSizes(); // Initial call

        // -------------------------
        // Excel Upload (Existing)
        // -------------------------
        const uploadExcelButton = document.querySelector('#uploadExcel');
        const excelFileInput = document.querySelector('#excelFileInput');
        const excelDropdown = document.querySelector('#excelDropdown');

        uploadExcelButton.addEventListener('click', () => {
          excelFileInput.click();
        });

        excelFileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                const filteredData = jsonData.filter(row => row && row.length >= 2 && row[0] != null && row[1] != null); // Ensure rows and required cells exist

                excelDropdown.innerHTML = '<option value="" disabled selected>Select</option>'; // Reset dropdown

                filteredData.forEach((row, index) => {
                    const option = document.createElement('option');
                    option.textContent = String(row[0]).substring(0, 50); // Limit title length display
                    option.value = index; // Use index as value
                    option.dataset.text = String(row[1]); // Store text in data attribute
                    excelDropdown.appendChild(option);
                });

                if (filteredData.length > 0) {
                    excelDropdown.classList.remove('hidden');
                } else {
                    excelDropdown.classList.add('hidden');
                    alert("No valid data found in the Excel file. Ensure Column A has titles and Column B has text.");
                }
            } catch (error) {
                 console.error("Error reading Excel file:", error);
                 alert("Error reading Excel file. Please ensure it's a valid .xlsx file with the correct format.");
                 excelDropdown.classList.add('hidden');
            }
          };
           reader.onerror = (error) => {
               console.error("File Reader Error:", error);
               alert("Could not read the file.");
           };
          reader.readAsArrayBuffer(file);
           // Clear the file input value to allow re-uploading the same file
           event.target.value = null;
        });

        excelDropdown.addEventListener('change', () => {
          const selectedOption = excelDropdown.options[excelDropdown.selectedIndex];
          // Check if it's a valid selection and has text data
          if (!selectedOption || selectedOption.disabled || !selectedOption.dataset.text) {
            return;
          }
          textarea.value = selectedOption.dataset.text;
          processText(); // Process the newly loaded text
        });

        // -------------------------
        // Speech Synthesis (Existing)
        // -------------------------
        const voiceSelect = document.getElementById('voiceSelect');
        const readAloudBtn = document.getElementById('readAloudBtn');
        const pauseResumeBtn = document.getElementById('pauseResumeBtn');
        let utterance = null;
        let isPaused = false;
        let originalText = '';
        let resumeOffset = 0; // tracks the index in originalText where speaking paused
        let isEdge = false; // Keep edge detection as is

        function detectDeviceAndBrowser() {
           const userAgent = navigator.userAgent.toLowerCase();
           let device = 'other';
           let browser = 'other';
           if (/windows nt/i.test(userAgent)) device = 'windows';
           else if (/macintosh/i.test(userAgent) && !/iphone|ipad/.test(userAgent)) device = 'mac';
           else if (/ipad|iphone|ipod/.test(userAgent) && !window.MSStream) device = 'ios';
           else if (/android/i.test(userAgent)) device = 'android';

           if (userAgent.indexOf('edg') > -1) browser = 'edge';
           else if (userAgent.indexOf('chrome') > -1 && userAgent.indexOf('safari') > -1 && userAgent.indexOf('opr') === -1) browser = 'chrome'; // More specific check
           else if (userAgent.indexOf('firefox') > -1) browser = 'firefox';
           else if (userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') === -1) browser = 'safari'; // Ensure it's not Chrome
           else if (userAgent.indexOf('opr') > -1 || userAgent.indexOf('opera') > -1) browser = 'opera';
           else if (userAgent.indexOf('trident') > -1) browser = 'ie';

           return { device, browser };
        }

        function populateVoiceList() {
           // Defensive check for speech synthesis support
           if (!('speechSynthesis' in window)) {
               console.warn("Speech Synthesis not supported in this browser.");
               readAloudBtn.disabled = true;
               pauseResumeBtn.disabled = true;
               voiceSelect.innerHTML = '<option value="" disabled selected>Speech not supported</option>';
               return;
           }

           const voices = speechSynthesis.getVoices();
           voiceSelect.innerHTML = ''; // Clear previous options

           const chineseVoices = voices.filter(v => v.lang.toLowerCase().startsWith('zh'));

           if (chineseVoices.length === 0) {
               const option = document.createElement('option');
               option.value = "";
               option.textContent = "No Chinese voices";
               option.disabled = true;
               option.selected = true;
               voiceSelect.appendChild(option);
               readAloudBtn.disabled = true; // Disable button if no voices
               return;
           }

           readAloudBtn.disabled = false; // Enable button if voices found

           // Add a default "Select Voice" option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select Voice";
            defaultOption.disabled = true;
            defaultOption.selected = true; // Make it selected initially
            voiceSelect.appendChild(defaultOption);


           chineseVoices.forEach(voice => {
               const option = document.createElement('option');
               option.value = voice.name;
               option.textContent = `${voice.name} (${voice.lang})`;
               // Add lang attribute for potential future use
               option.setAttribute('lang', voice.lang);
               voiceSelect.appendChild(option);
           });

           // Voice pre-selection logic (remains the same)
           const { device, browser } = detectDeviceAndBrowser();
           let targetKeyword = '';
           if (device === 'windows' && browser === 'edge') targetKeyword = 'yunyang';
           else if (device === 'windows' && browser === 'chrome') targetKeyword = 'huihui'; // Google voice often named differently
           else if (device === 'mac' || device === 'ios') targetKeyword = 'ting-ting'; // Common Mac/iOS voice, was meijia before
           else if (device === 'android') targetKeyword = 'taiwan'; // Android often uses network voices

           let found = false;
           if (targetKeyword) {
               for (let i = 0; i < voiceSelect.options.length; i++) {
                   if (voiceSelect.options[i].value.toLowerCase().includes(targetKeyword)) {
                       voiceSelect.selectedIndex = i;
                       found = true;
                       break;
                   }
               }
           }

            // If no specific voice found or needed, try to select a Mandarin mainland voice first
             if (!found) {
                 for (let i = 0; i < voiceSelect.options.length; i++) {
                     const lang = voiceSelect.options[i].getAttribute('lang');
                     if (lang && lang.toLowerCase() === 'zh-cn') {
                         voiceSelect.selectedIndex = i;
                         found = true;
                         break;
                     }
                 }
             }

           // If still not found, select the first *actual* voice option (index 1, as index 0 is "Select Voice")
           if (!found && voiceSelect.options.length > 1) {
               voiceSelect.selectedIndex = 1;
           }
        }

        // Ensure voices are loaded, might take time
        if (speechSynthesis.getVoices().length === 0) {
             speechSynthesis.onvoiceschanged = populateVoiceList;
        } else {
             populateVoiceList(); // Populate immediately if voices are already available
        }

        const { device: currentDevice, browser: currentBrowser } = detectDeviceAndBrowser();
         isEdge = (currentDevice === 'windows' && currentBrowser === 'edge');


         function readAloud() {
             const text = textarea.value.trim();
             if (!text) {
                 alert('Please enter some text first.');
                 return;
             }

             // Cancel any ongoing speech
             if (speechSynthesis.speaking || speechSynthesis.pending) {
                 isPaused = false; // Reset pause state
                 speechSynthesis.cancel();
                 // Short delay before starting new speech, especially after cancel
                 setTimeout(() => startSpeech(text), 100);
                 return;
             }

             startSpeech(text);
         }

         function startSpeech(text) {
             const selectedVoiceName = voiceSelect.value;
             if (!selectedVoiceName) {
                 alert('Please select a Chinese voice first.');
                 return;
             }

             const voiceObj = speechSynthesis.getVoices().find(v => v.name === selectedVoiceName);
             if (!voiceObj) {
                 alert('Selected voice not found. Please try another.');
                 populateVoiceList(); // Refresh list in case it changed
                 return;
             }

             utterance = new SpeechSynthesisUtterance(text);
             utterance.voice = voiceObj;
             utterance.lang = voiceObj.lang; // Set language for better pronunciation
             utterance.rate = 0.8;
             utterance.pitch = 1.0; // Reset pitch to normal
             utterance.volume = 1.0; // Ensure volume is max

             isPaused = false;
             pauseResumeBtn.disabled = false;
             pauseResumeBtn.textContent = 'Pause';
             originalText = text; // Store the text being spoken
             resumeOffset = 0; // Reset offset

             utterance.onstart = () => {
                 // console.log('Speech started');
                 isPaused = false;
                 pauseResumeBtn.textContent = 'Pause';
                 pauseResumeBtn.disabled = false;
             };

             utterance.onpause = () => {
                  // console.log('Speech paused');
                  isPaused = true;
                  pauseResumeBtn.textContent = 'Resume';
             };

              utterance.onresume = () => {
                   // console.log('Speech resumed');
                   isPaused = false;
                   pauseResumeBtn.textContent = 'Pause';
              };

             utterance.onend = () => {
                 // console.log('Speech ended');
                 isPaused = false;
                 pauseResumeBtn.disabled = true;
                 pauseResumeBtn.textContent = 'Pause';
                 utterance = null; // Clean up utterance object
                 resumeOffset = 0;
                 originalText = '';
             };

             utterance.onerror = (event) => {
                 console.error('SpeechSynthesis Error:', event.error);
                 alert(`Speech error: ${event.error}`);
                 isPaused = false;
                 pauseResumeBtn.disabled = true;
                 pauseResumeBtn.textContent = 'Pause';
                 utterance = null;
             };

             // Edge boundary workaround (remains the same)
             if (isEdge) {
                 utterance.onboundary = (event) => {
                     if (event.name === 'word') {
                         resumeOffset = event.charIndex;
                     }
                 };
             }

             speechSynthesis.speak(utterance);
         }

        readAloudBtn.addEventListener('click', readAloud);

        pauseResumeBtn.addEventListener('click', () => {
            if (!utterance && !speechSynthesis.speaking && !speechSynthesis.pending) {
                // Nothing to pause/resume
                pauseResumeBtn.disabled = true;
                return;
            }

             if (isEdge) {
                 // Edge workaround for pause/resume
                 if (!isPaused) { // Currently speaking, want to pause
                     speechSynthesis.cancel(); // Edge doesn't support pause well, so cancel
                     isPaused = true;
                     pauseResumeBtn.textContent = 'Resume';
                      // Keep button enabled to allow resume
                 } else { // Currently "paused" (cancelled), want to resume
                     isPaused = false;
                     pauseResumeBtn.textContent = 'Pause';
                     const remainingText = originalText.substring(resumeOffset);
                     if (remainingText.trim().length > 0) {
                         // Start new speech from the offset
                         // Need to recreate utterance essentially
                          console.log(`Resuming Edge speech from offset: ${resumeOffset}`);
                         // Need to select voice again etc. - wrap in a function?
                         // Re-use startSpeech logic but with substring?
                         startSpeech(remainingText); // This might reset originalText, need care
                         // Let's adjust startSpeech or create a resume function for Edge
                         // Quick fix: Directly create and speak new utterance here
                         const resumedUtterance = new SpeechSynthesisUtterance(remainingText);
                         const voiceObj = speechSynthesis.getVoices().find(v => v.name === voiceSelect.value);
                         if(voiceObj) {
                             resumedUtterance.voice = voiceObj;
                             resumedUtterance.lang = voiceObj.lang;
                         }
                         resumedUtterance.rate = 0.8;
                         resumedUtterance.pitch = 1.0;

                         // Need to re-attach handlers for the new utterance
                         resumedUtterance.onend = utterance.onend;
                         resumedUtterance.onerror = utterance.onerror;
                         // Boundary tracking needs to be relative to the new text + base offset
                         const baseOffset = resumeOffset;
                          resumedUtterance.onboundary = (event) => {
                              if (event.name === 'word') {
                                  resumeOffset = baseOffset + event.charIndex;
                              }
                          };
                         utterance = resumedUtterance; // Track the new utterance
                         speechSynthesis.speak(resumedUtterance);

                     } else {
                         // Nothing left to speak
                         pauseResumeBtn.disabled = true;
                         pauseResumeBtn.textContent = 'Pause';
                     }
                 }
             } else {
                 // Standard pause/resume for other browsers
                 if (speechSynthesis.speaking && !speechSynthesis.paused) {
                     speechSynthesis.pause();
                     // onpause handler should update state
                 } else if (speechSynthesis.paused) {
                     speechSynthesis.resume();
                     // onresume handler should update state
                 }
             }
        });


        // -------------------------
        // Auto-Show/Hide of Button Container (Existing)
        // -------------------------
        const buttonContainer = document.querySelector('.button-container');
        // Check if buttonContainer exists before adding listeners
        if (buttonContainer) {
            buttonContainer.classList.add('hidden'); // Hide initially
            const SHOW_ZONE = 180; // Activation zone height from bottom

             let hideTimeout = null;

             function showButtons() {
                 clearTimeout(hideTimeout); // Cancel any pending hide
                 buttonContainer.classList.remove('hidden');
             }

             function hideButtons() {
                 // Use a short delay before hiding in case the cursor briefly leaves the zone
                  hideTimeout = setTimeout(() => {
                      if (!buttonContainer.matches(':hover')) { // Only hide if not hovering over buttons
                          buttonContainer.classList.add('hidden');
                      }
                  }, 300); // 300ms delay
             }

             // Show on mouse move near bottom
             document.addEventListener('mousemove', (e) => {
                 if (window.innerHeight - e.clientY < SHOW_ZONE) {
                     showButtons();
                 } else {
                     hideButtons();
                 }
             });

             // Keep visible if mouse is over the button container itself
             buttonContainer.addEventListener('mouseenter', showButtons);
              buttonContainer.addEventListener('mouseleave', hideButtons);


             // Show on touch near bottom (for touch devices)
             document.addEventListener('touchstart', (e) => {
                 if (e.touches.length > 0) {
                     const touchY = e.touches[0].clientY;
                     if (window.innerHeight - touchY < SHOW_ZONE) {
                         showButtons();
                         // Optionally hide after a delay if no interaction? More complex.
                     } else {
                         // Don't immediately hide on touch outside zone, could be scrolling
                         // Maybe hide if touch ends outside?
                     }
                 }
             });

              // Hide if scrolling occurs and user is not in the zone?
               // This might be overly complex, the mousemove/hover logic is primary for desktop.

        } else {
            console.error("Button container not found.");
        }


        // ------------------------------------------------------------------
        //  >>> Hide Read-Aloud UI on mobile <<< (Existing)
        // ------------------------------------------------------------------
        {
          const { device } = detectDeviceAndBrowser();
          // If the device is not detected as Windows or Mac, assume mobile/tablet
          if (device !== 'windows' && device !== 'mac') {
              if(readAloudBtn) readAloudBtn.style.display = 'none';
              if(voiceSelect) voiceSelect.style.display = 'none';
              if(pauseResumeBtn) pauseResumeBtn.style.display = 'none';
             // Consider showing the alert only once using localStorage or sessionStorage
              // if (!sessionStorage.getItem('readAloudAlertShown')) {
              //     alert('Note: The read-aloud feature is best experienced on PCs.');
              //     sessionStorage.setItem('readAloudAlertShown', 'true');
              // }
          }
        }

        // -------------------------
        // Visitor Counter and Admin Popup (Existing)
        // -------------------------
        // (DOMContentLoaded ensures this runs after elements are ready)
        const pv = document.getElementById('pageviews');
        if (pv !== null) {
          const uri = location.pathname.replace(/\/$/, '') || '/'; // Handle root path
          const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;
          fetch(url)
            .then((response) => {
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return response.json();
            })
            .then((data) => {
                // Ensure count exists and format it
                const count = data && data.count ? data.count.replace(/\s/g, '') : 'N/A';
                if (count !== 'N/A') {
                   pv.innerText = new Intl.NumberFormat().format(count);
                } else {
                   pv.innerText = 'N/A';
                }
            })
            .catch((error) => {
              console.error("Failed to fetch pageviews:", error);
              pv.innerText = 'N/A'; // Indicate failure to load
            });
        } else {
             console.warn("Pageviews element not found.");
        }

        const adminPopup = document.getElementById('adminPopup');
        const closeBtn = document.getElementById('adminPopupCloseBtn');

        // Show popup only if it hasn't been closed this session
        if (adminPopup && closeBtn && !sessionStorage.getItem('adminPopupClosed')) {
            adminPopup.classList.remove('hidden');
            closeBtn.addEventListener('click', () => {
                adminPopup.classList.add('hidden');
                // Remember that the popup was closed for this session
                 sessionStorage.setItem('adminPopupClosed', 'true');
            });
        } else if(adminPopup) {
             // Ensure it's hidden if already closed this session or elements are missing
             adminPopup.classList.add('hidden');
        }


        // -------------------------
        // NEW Resizer Logic
        // -------------------------
        const resizerEl = document.querySelector('.resizer');
        const leftPanel = inputSection; // Use existing variable
        const rightPanel = outputSection; // Use existing variable

        let isPanelResizing = false;
        let panelStartX, panelStartLeftWidth, panelStartRightWidth;

        // Check if all necessary elements exist before adding listeners
        if (resizerEl && leftPanel && rightPanel) {
            resizerEl.addEventListener('mousedown', (e) => {
                 // Ignore resize if input panel is hidden (output is fullscreen)
                 if(leftPanel.classList.contains('fullscreen-hidden')) {
                     return;
                 }

                isPanelResizing = true;
                panelStartX = e.clientX;
                // Use getBoundingClientRect for width including padding/border if box-sizing is border-box
                panelStartLeftWidth = leftPanel.getBoundingClientRect().width;
                panelStartRightWidth = rightPanel.getBoundingClientRect().width;

                document.body.classList.add('resizing');

                // Attach listeners to document for global drag tracking
                document.addEventListener('mousemove', handlePanelMouseMove);
                document.addEventListener('mouseup', handlePanelMouseUp);

                // Prevent default text selection behavior during drag
                e.preventDefault();
            });

            function handlePanelMouseMove(e) {
                if (!isPanelResizing) return;

                const dx = e.clientX - panelStartX;
                let newLeftWidth = panelStartLeftWidth + dx;
                let newRightWidth = panelStartRightWidth - dx;

                // Get min-width from computed style (remove 'px')
                const leftMinWidth = parseInt(window.getComputedStyle(leftPanel).minWidth, 10) || 0;
                const rightMinWidth = parseInt(window.getComputedStyle(rightPanel).minWidth, 10) || 0;

                // Enforce minimum widths and adjust the other panel accordingly
                if (newLeftWidth < leftMinWidth) {
                    newLeftWidth = leftMinWidth;
                    // Recalculate right width based on fixed left width
                    newRightWidth = panelStartLeftWidth + panelStartRightWidth - newLeftWidth;
                }
                if (newRightWidth < rightMinWidth) {
                    newRightWidth = rightMinWidth;
                    // Recalculate left width based on fixed right width
                    newLeftWidth = panelStartLeftWidth + panelStartRightWidth - newRightWidth;
                }

                 // Final check in case both panels were adjusted and might violate min-width again
                 if (newLeftWidth < leftMinWidth) newLeftWidth = leftMinWidth;
                 if (newRightWidth < rightMinWidth) newRightWidth = rightMinWidth;

                 // Check if total width allows for min-widths (prevent infinite loop/weirdness)
                 if (newLeftWidth + newRightWidth > panelStartLeftWidth + panelStartRightWidth) {
                     // This shouldn't happen if calculations are correct, but as a safeguard:
                     // console.warn("Resizing calculation issue.");
                     // Maybe revert to a proportional adjustment if constraints conflict badly?
                     // For now, applying the constrained widths is likely best.
                 }

                // Apply new widths using flex-basis in pixels. This overrides flex-grow/shrink.
                leftPanel.style.flexBasis = `${newLeftWidth}px`;
                rightPanel.style.flexBasis = `${newRightWidth}px`;

                // Explicitly set grow/shrink to 0 to prevent flexbox from redistributing space
                // leftPanel.style.flexGrow = '0';
                // leftPanel.style.flexShrink = '0';
                // rightPanel.style.flexGrow = '0';
                // rightPanel.style.flexShrink = '0';

                // No need to preventDefault here, already done on mousedown
                // and body class handles user-select
            }

            function handlePanelMouseUp() {
                if (isPanelResizing) {
                    isPanelResizing = false;
                    document.body.classList.remove('resizing');
                    document.removeEventListener('mousemove', handlePanelMouseMove);
                    document.removeEventListener('mouseup', handlePanelMouseUp);

                    // Optional: Could recalculate flex-basis in percentages here for responsiveness,
                    // but pixel-based basis usually works fine and maintains user preference.
                }
            }
        } else {
            console.error("Resizer elements (.resizer, .input-section, .output-section) not found. Resizing disabled.");
            // Hide the resizer visually if elements are missing
            if(resizerEl) resizerEl.style.display = 'none';
        }

      }); // End of DOMContentLoaded listener
    </script>
  </body>
</html>
